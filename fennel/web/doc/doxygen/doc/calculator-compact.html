<html>

<head>
<meta http-equiv=Content-Type content="text/html; charset=iso-8859-1">
<title>Calculator Design Specification</title>
<link rel="stylesheet" type="text/css" href="../../stylesheet.css" />
</head>

<body>

<h1>Calculator Design Specification</h1>

<hr>

<p>John Kalucki, 2/22/2004</p>

<p>Copyright (C) 2003-2005, Disruptive Tech, Inc.</p>

<h1>Overview</h1>

<p><b>Calculator</b> is a portable C++ component that executes
small <b>programs</b> very efficiently. Programs consist of a list of <b>instructions</b>,
input data, <b>literals</b> (constants), and scratch memory. Generally programs
result in some output data. A simple <b>virtual machine</b> (VM) executes
programs and terminates. </p>

<p>A typical Calculator object life-cycle &amp; use-pattern:</p>

<ol>
	<li>Instantiate Calculator</li>
	<li>Assemble Instructions: Create and Insert Instructions into
Calculator</li>
	<li>Allocate Required Memory</li>
	<li>Bind Input, Output, and Literals to Calculator</li>
	<li>Execute Program</li>
	<li>Check Status Register</li>
	<li>Utilize Output </li>
	<li>As Needed: Bind New Input. </li>
	<li>As Needed: Bind new Output</li>
	<li>As Needed: Jump to #5</li>
	<li>Destroy Calculator</li>
	<li>De-allocate memory</li>
</ol>

<p>Calculator will be installed as a component of <a
href="http://sourceforge.net/projects/fennel/">Fennel</a>. Coding standards,
build environment, etc. are to follow the Fennel project&#8217;s example. Calculator
will introduce no additional dependencies to Fennel.</p>

<p>The primary goals of this Calculator design are Execution
Performance and, as a pair: Extensibility and Maintainability. Overall
performance for the single execution case will be considered as well as case
where the same program is executed repeatedly over a varying set of inputs and
outputs.</p>

<p>Calculator can call <b>external functions </b>for
extensibility and to efficiently handle complex operations. For example, string
concatenation could involve a call to strncpy() instead of having the VM
perform a painful byte-by-byte copy of the string. A strongly-typed version of
external functions called <b>extended instructions</b> allows Calculator to be
extended in a type-safe way.</p>

<p>Calculator will interact directly and indirectly with a
number of other components. A <b>compiler</b> will create programs. Typically
the compiler will instantiate instruction objects and insert them into a list.
Once finished, the compiler will ask the instruction for a serial
representation and create a text version of the program. The compiler may, at
its option, also create the program text directly, but will give up the
implicit type checking and other features.</p>

<p>An <b>Execution Object (XO)</b> will call the <b>assembler</b>
with a text program. The assembler will allocate some of the register sets, and
re-create the instruction object list, inserting the instructions into a
Calculator object. Later, the XO can bind data, and execute Calculator.</p>

<h1>Memory Architecture</h1>

<h2>Register Sets</h2>

<p>Memory is modeled as a number of <b>register sets</b>. Each
register set is stored in an array. Individual registers are accessed by an
0-based index into the set. Register sets are currently a simple abstraction from
Fennel Tuples. </p>

<p>Calculator will perform all memory allocation during
instantiation and configuration and no memory allocation during typical
execution paths. <b>Warning Messages</b> and <b>Error Messages</b> may be
allocated at runtime, however. See Warnings &amp; Errors below. The caller will
be responsible for allocating and de-allocating register sets.</p>

<p>Note: External functions and extended instructions may
perform resource allocation as a side-effect. Calculator makes no attempt to
track resource allocation. The program writer must explicitly call appropriate
external functions to de-allocate such memory. </p>

<p>There are five register sets defined:</p>

<h3>1. Input: </h3>

<p>a. Input of program data. (i.e. function arguments)</p>

<p>b. Generally contains&nbsp;
tuple data handed to XO.</p>

<p>c. Intended to be the main variant when Calculator programs are
executed repeatedly.</p>

<h3>2. Output:</h3>

<p>a. Output of program data. (i.e. function return values)</p>

<p>b. Generally contains the tuple to be passed out of the XO.</p>

<p>c. Storage of intermediate results between program executions.
(e.g. Aggregation Functions)</p>

<p>d. A compiler might also choose to store metadata such as
exceptions, errors, warnings, overflow indicator bits, etc. in the output
register set, but this usage is discouraged. Storing such data here requires
the XO to filter the tuple before passing it on to the next XO.</p>

<h3>3. Local: (&#8220;Intermediates&#8221;)</h3>

<p>a. General purpose intermediate storage.</p>

<p>b. Intermediate storage for integral types. (i.e. main memory)</p>

<p>c. Pre-allocated &#8220;heap space&#8221; for scratch storage of strings and
other Large Objects.</p>

<h3>4. Literals: (&#8220;Constants&#8221;)</h3>

<p>a. When Calculator programs are executed repeatedly, static
literals need not be mixed with changing input tuples.</p>

<p>b. Literal register set is allocated and set by the assembler,
not by the XO.</p>

<p>c. For a very small increase in Calculator complexity, there is
potentially a win in reduction of binding overhead.</p>

<p>d. Explicitly supporting literals in a register set obviates the
need for a literal addressing mode and its associated complexity (e.g. <code>ADD Local(4), $0x200</code> is not needed. $0x200 is
loaded from the Literals register instead: <code>ADD
Local(4), Literal(3)</code>)</p>

<h3>5. Status:</h3>

<p>a. Provide a generic and flexible location for programs to
communicate with the XO.</p>

<p>b. Prevents status information from mixing with the output
register set, obviating the need for filtering the output tuple in the XO.</p>

<p>c. Allows for rich interaction between programs and XO without
also requiring modification to Calculator.</p>

<p>Register sets will not be cleared or otherwise manipulated
by Calculator object. Only two types of objects within the Calculator component
will manipulate register sets: the assembler and subclasses of the Instruction
class. By not clearing register sets, the output register set may also be used
as input as well as output for instructions.</p>

<h2>Addressing Modes</h2>

<p>Genuflecting to John Hennessy and Dave Patterson,
Calculator&#8217;s addressing modes will be orthogonal:</p>

<p>1. All operands of all instructions that reference memory can use
all addressing modes</p>

<p>2. All register sets are readable and writeable by all
instructions. However, sensible programming conventions would discourage
inappropriate use of sets. (e.g. writing to the input and literal register
sets)</p>

<p>3. All memory locations of a given type (and/or length, see
Storage, below) can be used interchangeably.</p>

<p>4. No &#8220;special&#8221; registers.</p>

<p>5. All memory accesses will be typed. (Instructions will cast all
accesses as the desired type.)</p>

<p>Efficiency is paramount! Operands in programs will be
indexes into a given register set. For example: Output[4] or Input[0]. The <code>RegisterReference </code>class will provide an
abstraction to allow various implementations of, experiments with, and
debug-level instrumentation of, all memory access.</p>

<p>A consideration: <code>RegisterReference</code>
may cache the abstract register set reference &#8220;Local [4]&#8221; as a direct pointer
to memory by setting the <code>CachePointer</code>
property. Tuning may indicate that this is valuable when applied to register
sets that do not change, such as the Literal set and the Local set, but
reference invalidation costs for sets that typically re-bound before each
execution may not be worth the cost. The implication is that local memory
access may be somewhat faster than Input or Output access. <b>TBD</b>.</p>

<p>A consideration: Add an additional indexing addressing mode
that allows easier manipulation of one-dimensional and multi-dimensional
arrays, jump tables for CASE statements, and perhaps the register sets
themselves. For example, the 80386 architecture supports a Scale/Index/Base
addressing mode. Addresses are calculated as (Scale * Index) + Base. <b>TBD</b></p>

<p>Nested rows issues? <b>TBD</b></p>

<p>Multiple rows per execution? (e.g. batch) <b>TBD</b>.</p>

<h2>Storage</h2>

<p><b><u>Portability Invariant</u></b>: A given program and
input should produce (nearly) identical output on each and every supported
hardware type. Calculator must be independent of underlying hardware &#8211; with
sole and notable exception of rounding errors in floating point numbers. </p>

<p>Native type support, storage, typedefs, etc. are provided by
Fennel Tuples. Fennel supports types beyond the native C++ types, such as
VARCHAR, VARBINARY, and so forth. Therefore Calculator types are defined by the
Fennel enum <code>StandardTypeDescriptorOrdinal.</code></p>

<h2>Types</h2>

<p>The Calculator is strongly typed:</p>

<ul type=disc>
 <li>Default
     execution mode will assume that a program is type correct.</li>
 <li>Behavior
     may be undefined if type violations occur.</li>
 <li>Calculator
     is strongly typed within instructions but not between instructions and
     underlying tuples. Runtime type checking is not supported!</li>
 <li>Explicit
     type conversions are required for type promotion, demotion and
     transformation.</li>
 <li>With
     the exception of extended instructions and external functions, the return
     type of all other instructions is implicitly determined by the associated
     input types. Note: The serialized version of&nbsp; programs may redundantly require output type to be
     declared to enforce a regular representation and make parsing easier for
     the assembler.</li>
 <li>Instructions
     that take two operands typically require that both operands be of the same
     type, unless noted otherwise.</li>
 <li>Trace
     and debug modes may or may/not enforce typing. <b>TBD</b>.</li>
</ul>

<p>The implication is that the compiler must be aware of types,
and must <u>always</u> Do The Right Thing.</p>

<h2>Type Mappings</h2>

<p>Mappings between SQL types and C++ native types is provided
by the Fennel Tuple code. (See
<a href="http://farrago.sourceforge.net/api/net/sf/farrago/query/FennelRelUtil.html#convertSqlTypeNameToFennelType(org.eigenbase.sql.type.SqlTypeName)">
documentation for SQL to Fennel type mapping</a>.) Some types, such as SQL&#8217;s 
<code>DECIMAL(p,s)</code> and <code>TIMESTAMP(p)</code> types are not
directly supported by Calculator. The compiler should handle this type by generating
appropriate programs.</p>

<p>Tuple represent NULL values with a NULL pointer. </p>

<p>Non-native types supported by
Fennel Tuples, such as <code>VARCHAR</code>, are simply represented by a pointer in the
Calculator, and perhaps also an integer containing the length of the array.</p>

<p>When represented as strings, for example in serialized
programs, the mapping from StandardTypeDescriptorOrdinal to strings is defined
by <code>standardTypetoString()</code> located in <code>fennel/calc/StandardTypeToString.cpp.</code></p>

<p align=center></p>

<table border=1 cellspacing=0 cellpadding=0 width=336>
 <tr>
  <th valign=bottom>
  <p>Fennel/Tuple/ StandardTypeDescriptorOrdinal</p>
  </th>
  <th valign=bottom>
  <p>String Representation</p>
  </th>
 </tr>
 <tr>
  <td width=217 nowrap valign=bottom>
  <p><code>STANDARD_TYPE_INT_8</code></p>
  </td>
  <td width=119 nowrap valign=bottom>
  <p align=center><code>s1</code></p>
  </td>
 </tr>
 <tr>
  <td width=217 nowrap valign=bottom>
  <p><code>STANDARD_TYPE_UINT_8</code></p>
  </td>
  <td width=119 nowrap valign=bottom>
  <p align=center><code>u1</code></p>
  </td>
 </tr>
 <tr>
  <td width=217 nowrap valign=bottom>
  <p><code>STANDARD_TYPE_INT_16</code></p>
  </td>
  <td width=119 nowrap valign=bottom>
  <p align=center><code>s2</code></p>
  </td>
 </tr>
 <tr>
  <td width=217 nowrap valign=bottom>
  <p><code>STANDARD_TYPE_UINT_16</code></p>
  </td>
  <td width=119 nowrap valign=bottom>
  <p align=center><code>u2</code></p>
  </td>
 </tr>
 <tr>
  <td width=217 nowrap valign=bottom>
  <p><code>STANDARD_TYPE_INT_32</code></p>
  </td>
  <td width=119 nowrap valign=bottom>
  <p align=center><code>s4</code></p>
  </td>
 </tr>
 <tr>
  <td width=217 nowrap valign=bottom>
  <p><code>STANDARD_TYPE_UINT_32</code></p>
  </td>
  <td width=119 nowrap valign=bottom>
  <p align=center><code>u4</code></p>
  </td>
 </tr>
 <tr>
  <td width=217 nowrap valign=bottom>
  <p><code>STANDARD_TYPE_INT_64</code></p>
  </td>
  <td width=119 nowrap valign=bottom>
  <p align=center><code>s8</code></p>
  </td>
 </tr>
 <tr>
  <td width=217 nowrap valign=bottom>
  <p><code>STANDARD_TYPE_UINT_64</code></p>
  </td>
  <td width=119 nowrap valign=bottom>
  <p align=center><code>u8</code></p>
  </td>
 </tr>
 <tr>
  <td width=217 nowrap valign=bottom>
  <p><code>STANDARD_TYPE_REAL</code></p>
  </td>
  <td width=119 nowrap valign=bottom>
  <p align=center><code>r</code></p>
  </td>
 </tr>
 <tr>
  <td width=217 nowrap valign=bottom>
  <p><code>STANDARD_TYPE_DOUBLE</code></p>
  </td>
  <td width=119 nowrap valign=bottom>
  <p align=center><code>d</code></p>
  </td>
 </tr>
 <tr>
  <td width=217 nowrap valign=bottom>
  <p><code>STANDARD_TYPE_CHAR</code></p>
  </td>
  <td width=119 nowrap valign=bottom>
  <p align=center><code>c</code></p>
  </td>
 </tr>
 <tr>
  <td width=217 nowrap valign=bottom>
  <p><code>STANDARD_TYPE_VARCHAR</code></p>
  </td>
  <td width=119 nowrap valign=bottom>
  <p align=center><code>vc</code></p>
  </td>
 </tr>
 <tr>
  <td width=217 nowrap valign=bottom>
  <p><code>STANDARD_TYPE_BINARY</code></p>
  </td>
  <td width=119 nowrap valign=bottom>
  <p align=center><code>b</code></p>
  </td>
 </tr>
 <tr>
  <td width=217 nowrap valign=bottom>
  <p><code>STANDARD_TYPE_VARBINARY</code></p>
  </td>
  <td width=119 nowrap valign=bottom>
  <p align=center><code>vb</code></p>
  </td>
 </tr>
</table>

<p/>

<h1>Internationalization</h1>

<p>Internationalization issues are expected to be transparent
to Calculator. Byte arrays are represented by pointers.</p>

<h1>Isolation</h1>

<p>It&#8217;s a Mad Mad Mad Mad World. Under normal running
conditions, Calculator will make no attempt to isolate the C++ process from
potentially ill side effects of Calculator program execution. This
responsibility is completely up to the program compiler and the author of
extended instructions.</p>

<p>&nbsp;Risks not
handled, include, but are not limited to:</p>

<ul type=disc>
 <li>C++
     memory corruption - Anywhere the address space, not just in register sets!</li>
 <li>C++
     stack corruption &#8211; Another example of memory corruption.</li>
 <li>C++
     program counter corruption &#8211; e.g. jump to hyperspace, segmentation fault,
     core dump.</li>
 <li>VM
     program counter corruption &#8211; e.g. jump to hyperspace, segmentation fault,
     core dump.</li>
 <li>VM
     program non-termination. &#8211; i.e. Calculator.exec() does not return.</li>
 <li>Resource
     leakage from external function calls &#8211; Typically memory leakage, but
     potentially file descriptors or any other resource that an external
     function call could abandon.</li>
 <li>Unaligned
     memory access &#8211; e.g. bus error, core dump.</li>
 <li>Security,
     Access control violations, etc.</li>
</ul>

<p>Some of these risks could be mitigated by only allowing a tightly
controlled list of external functions to be called. </p>

<p>Risks handled:</p>

<ul type=disc>
 <li>Division
     by Zero &#8211; Generates a warning.</li>
 <li>Modulus
     by Zero &#8211; Generates a warning.</li>
 <li>Arithmetic
     Overflow: <b>TBD</b></li>
 <li>Arithmetic
     Underflow: <b>TBD</b></li>
</ul>

<p>Each instruction that may bump into these risks will have to
handle them in a well defined manner and provide the appropriate error, warning
or exception. </p>

<h1>Calculator Programs</h1>

<h2>Representation</h2>

<p>Calculator programs can be created and represented in
several ways:</p>

<p>1) In-process C++ can access the instruction set OO hierarchy
directly, cons up instruction objects, order them into programs, and have
Calculator execute them. This is the typical Fennel access mode.</p>

<p>2) Out-of-process C++ can link in Calculator code to access the
instruction set OO hierarchy directly. Each instruction can convert itself into
a serialized (string) representation.&nbsp;
The serial representation can be transmitted to another C++ process for
assembly and execution. See Assembler section for details on the format of
these strings.</p>

<p>3) In
or Out of process Java creates, via some arbitrary method, a string
representation of a program. The program can be transmitted to a C++ process. </p>

<p>4) Out-of-process
C++ can also use method #3.</p>

<h2>Flow Control</h2>

<p>All jumps are to absolute instruction &#8220;addresses&#8221;. The
effective address of an instruction is determined solely by the order that it
is inserted into Calculator. The first instruction inserted is at address 0 &#8211;
that is to say, instruction addresses are 0-indexed</p>

<p>Jump labels, instead of absolute jump addresses would make programs
easier to read and debug, but would add complexity to Calculator and perhaps to
the compiler. For now, labels are not supported. A compiler and program writer
might consider implementing labels as a convenience in creating programs.</p>

<p>A consideration: May want to provide some support for
efficient processing of SQL CASE statements, such as the SIB addressing mode
mentioned above.</p>

<h2>Exceptions</h2>

<p>Yet to be fully specified. TBD</p>

<p>Will use the RAISE instruction.</p>

<p>May want to support catch, throw, try, finally.</p>

<p>When an exception is thrown in a program, Calculator will
eventually throw a C++ exception that the caller to Calculator.exec() is
encouraged to catch and decode.</p>

<p>Format and values of object thrown by exception <b>TBD</b>.</p>

<h2>Extended Instructions</h2>

<p>Implemented, but not currently documented. <b>TBD</b></p>

<h2>External Functions</h2>

<p>Yet to be specified. TBD</p>

<p>Will have some form of static lookup table of supported
functions. </p>

<p>Assembler will have to convert a string function name into a
function pointer.</p>

<p>Will have to support a pointer type.</p>

<p>John Sichi has recommended looking at Functors. Look at
Boost Functors. May be useful here.</p>

<p>Provide/find optimized str(3) functions that handle SQL
semantics correctly. (e.g.&nbsp;
ignoring trailing spaces, varbinary blobs of unequal length)</p>

<p>Consider resource allocation issues.</p>

<p>Consider how to represent Null stings vs. empty strings,
etc.</p>

<h2>NULL</h2>

<p>Fennel Tuples represent NULL values as a NULL pointer.
RegisterReference handles this convention.</p>

<p>All instructions will be NULL-aware and will implement
appropriate SQL NULL semantics.</p>

<p>If a Local register may be set to NULL, and if Calculator
will be called more than once, the Local register set must have the <code>PointerReset </code>property set. This property causes
Calculator to reset the tuple pointer back to its original location before the
next call to exec().</p>

<p>Writing programs to test every location for IsNotNULL before each write
could be a real bear. Program writers are encouraged to make liberal use of
Local registers to avoid this problem. It&#8217;s possible that this representation
of NULL is simply not strong enough, and Tuples will have to be changed to
reflect this problem. TBD</p>

<p>Effect on strings and external functions? <b>TBD</b></p>

<h2>Warnings and Errors</h2>

<p>The compiler must take warning recovery and error handling
into account. The compiler can decide if it wishes to perform <b>exception
avoidance</b> by testing for common errors within the program, or let
Calculator execute and handle the issue.</p>

<p>Warning and error codes codes are taken from Section 22.1
SQLSTATE of the SQL99 specification. Arbitrarily, Calculator&#8217;s
implementation-defined errors are in the Class <b>5Z</b>. This choice should be
rationalized. <b>TBD</b>.</p>

<p>Warnings are the result of correctable problems. Program
execution always continues after warnings and side-effects are well defined.
Warning messages are coded and placed onto a deque (double-ended queue) for
later access. A deque is used to allow interpretation of warnings in the order
that they occurred (iterate from deque.begin()) or to allow interpretation of
the last warning first (iterate from deque.end())</p>

<p>Warnings:</p>

<table border=1 cellspacing=0 cellpadding=0>
 <tr>
  <th width=178 valign=top>
  <p>Warning</p>
  </th>
  <th width=108 valign=top>
  <p>Code Class/Subclass</p>
  </th>
  <th width=214 valign=top>
  <p>Side-effect(s)</p>
  </th>
  <th width=446 valign=top>
  <p>Comments</p>
  </th>
 </tr>
 <tr>
  <td width=178 valign=top>
  <p><code>Division By Zero</code></p>
  </td>
  <td width=108 valign=top>
  <p><code>22012</code></p>
  </td>
  <td width=214 valign=top>
  <p>Result contains a NULL.
  </p>
  </td>
  <td width=446 valign=top>
  <p>SQL99 spec appears to
  state that DIV/0 is an error. A side-effect is not specified. Consider making
  Division By Zero an Error. TBD</p>
  </td>
 </tr>
 <tr>
  <td width=178 valign=top>
  <p><code>Overflow</code></p>
  </td>
  <td width=108 valign=top>
  <p><code>22003</code></p>
  </td>
  <td width=214 valign=top>
  <p>Round or Truncate? TBD</p>
  </td>
  <td width=446 valign=top>
  <p>SQL99 says
  implementation may round or truncate</p>
  </td>
 </tr>
 <tr>
  <td width=178 valign=top>
  <p><code>Underflow</code></p>
  </td>
  <td width=108 valign=top>
  <p><code>22003</code></p>
  </td>
  <td width=214 valign=top>
  <p>Round or Truncate? TBD</p>
  </td>
  <td width=446 valign=top>
  <p>Does this even exist?</p>
  </td>
 </tr>
</table>

<p>&nbsp;</p>

<p>Errors are problems that are not correctable, or problems
with side-effects that are not well defined. Program execution always
terminates immediately after errors. Error status is indicated in the last
element of the warning deque. An exception is thrown after the error message is
added to the warning queue. Format of this exception <b>TBD</b>.</p>

<p>Errors:</p>

<table border=1 cellspacing=0 cellpadding=0>
 <tr>
  <th width=178 valign=top>
  <p>Error</p>
  </th>
  <th width=107 valign=top>
  <p>Code</p>
  </th>
  <th width=214 valign=top>
  <p>Side-effect(s)</p>
  </th>
  <th width=446 valign=top>
  <p>Comments</p>
  </th>
 </tr>
 <tr>
  <td width=178 valign=top>
  <p><code>Segmentation Fault</code></p>
  </td>
  <td width=107 valign=top>
  <p><code>5Z001</code></p>
  </td>
  <td width=214 valign=top>
  <p>&nbsp;</p>
  </td>
  <td width=446 valign=top>
  <p>PC falls off end of
  program and/or jumps to a non-existent location.</p>
  </td>
 </tr>
</table>

<p>&nbsp;</p>

<h2>Instruction Set</h2>

<table border=1 cellpadding=0 width=768>
 <tr>
  <th rowspan=2 valign=top>
  <p>Base
  Class Name</p>
  </th>
  <th rowspan=2 valign=top>
  <p>Object
  Name</p>
  </th>
  <th width=74 rowspan=2 valign=top>
  <p>OpCode
  Mnemonic<br>
  &amp; <br>
  String Representation</p>
  </th>
  <th width=99 rowspan=2 valign=top>
  <p>Operands</p>
  </th>
  <th rowspan=2 valign=top>
  <p>Comment</p>
  </th>
  <th width=38 colspan=4>
  <p align=center>Type Support</p>
  </th>
 </tr>
 <tr>
  <th width=38 valign=top>
  <p><code>bool</code></p>
  </th>
  <th width=38 valign=top>
  <p><code>long</code> <code>ulong</code></p>
  </th>
  <th width=38 valign=top>
  <p><code>float</code><br>
  <code>long double</code></p>
  </th>
  <th width=38 valign=top nowrap>
  <p><code>T
  *</code></p>
  </th>
 </tr>
 <tr>
  <td valign=top>
  <p><code>·BooleanInstruction</code></p>
  </td>
  <td valign=top>
  <p><code>BoolAnd</code></p>
  </td>
  <td width=74 valign=top>
  <p><code>AND</code></p>
  </td>
  <td width=99 rowspan=2 valign=top>
  <p><code>result, operand, operand</code></p>
  </td>
  <td rowspan=2 valign=top>
  <p><br><br></code></p>
  </td>
  <td width=38 rowspan=11>
  <p align=center><code>Y</code></p>
  </td>
  <td width=38>
  <p align=center>&nbsp;</p>
  </td>
  <td width=38>
  <p align=center>&nbsp;</p>
  </td>
  <td width=38>
  <p align=center>&nbsp;</p>
  </td>
 </tr>
 <tr>
  <td valign=top>
  <p>&nbsp;</p>
  </td>
  <td valign=top>
  <p><code>BoolOr</code></p>
  </td>
  <td width=74 valign=top>
  <p><code>OR</code></p>
  </td>
  <td width=38>
  <p align=center>&nbsp;</p>
  </td>
  <td width=38>
  <p align=center>&nbsp;</p>
  </td>
  <td width=38>
  <p align=center>&nbsp;</p>
  </td>
 </tr>
 <tr>
  <td valign=top>
  <p>&nbsp;</p>
  </td>
  <td valign=top>
  <p><code>BoolEqual</code></p>
  </td>
  <td width=74 valign=top>
  <p><code>EQ</code></p>
  </td>
  <td width=99>
  <p>&nbsp;</p>
  </td>
  <td>
  <p>Equivalent to SQL
  boolean <code>IS</code></p>
  </td>
  <td width=38>
  <p align=center>&nbsp;</p>
  </td>
  <td width=38>
  <p align=center>&nbsp;</p>
  </td>
  <td width=38>
  <p align=center>&nbsp;</p>
  </td>
 </tr>
 <tr>
  <td valign=top>
  <p>&nbsp;</p>
  </td>
  <td valign=top>
  <p><code>BoolNotEqual</code></p>
  </td>
  <td width=74 valign=top>
  <p><code>NE</code></p>
  </td>
  <td width=99 rowspan=3>
  <p>&nbsp;</p>
  </td>
  <td>
  <p>Equivalent to SQL
  boolean <code>IS NOT</code></p>
  </td>
  <td width=38>
  <p align=center>&nbsp;</p>
  </td>
  <td width=38>
  <p align=center>&nbsp;</p>
  </td>
  <td width=38>
  <p align=center>&nbsp;</p>
  </td>
 </tr>
 <tr>
  <td valign=top>
  <p>&nbsp;</p>
  </td>
  <td valign=top>
  <p><code>BoolGreater</code></p>
  </td>
  <td width=74 valign=top>
  <p><code>GT</code></p>
  </td>
  <td rowspan=2 valign=top>
  <p><code>TRUE</code> &gt; <code>FALSE</code>. No
  need for GE, LE</p>
  </td>
  <td width=38>
  <p align=center>&nbsp;</p>
  </td>
  <td width=38>
  <p align=center>&nbsp;</p>
  </td>
  <td width=38>
  <p align=center>&nbsp;</p>
  </td>
 </tr>
 <tr>
  <td valign=top>
  <p>&nbsp;</p>
  </td>
  <td valign=top>
  <p><code>BoolLess</code></p>
  </td>
  <td width=74 valign=top>
  <p><code>LT</code></p>
  </td>
  <td width=38>
  <p align=center>&nbsp;</p>
  </td>
  <td width=38>
  <p align=center>&nbsp;</p>
  </td>
  <td width=38>
  <p align=center>&nbsp;</p>
  </td>
 </tr>
 <tr>
  <td valign=top>
  <p>&nbsp;</p>
  </td>
  <td valign=top>
  <p><code>BoolNot</code></p>
  </td>
  <td width=74 valign=top>
  <p><code>NOT</code></p>
  </td>
  <td width=99 rowspan=3>
  <p><code>result, operand</code></p>
  </td>
  <td>
  <p>&nbsp;</p>
  </td>
  <td width=38>
  <p align=center>&nbsp;</p>
  </td>
  <td width=38>
  <p align=center>&nbsp;</p>
  </td>
  <td width=38>
  <p align=center>&nbsp;</p>
  </td>
 </tr>
 <tr>
  <td valign=top>
  <p>&nbsp;</p>
  </td>
  <td valign=top>
  <p><code>BoolMove</code></p>
  </td>
  <td width=74 valign=top>
  <p><code>MOVE</code></p>
  </td>
  <td>
  <p>&nbsp;</p>
  </td>
  <td width=38>
  <p align=center>&nbsp;</p>
  </td>
  <td width=38>
  <p align=center>&nbsp;</p>
  </td>
  <td width=38>
  <p align=center>&nbsp;</p>
  </td>
 </tr>
 <tr>
  <td valign=top>
  <p>&nbsp;</p>
  </td>
  <td valign=top>
  <p><code>BoolIsNull</code></p>
  </td>
  <td width=74 valign=top>
  <p><code>ISNULL</code></p>
  </td>
  <td>
  <p>&nbsp;</p>
  </td>
  <td width=38>
  <p align=center>&nbsp;</p>
  </td>
  <td width=38>
  <p align=center>&nbsp;</p>
  </td>
  <td width=38>
  <p align=center>&nbsp;</p>
  </td>
 </tr>
 <tr>
  <td valign=top>
  <p>&nbsp;</p>
  </td>
  <td valign=top>
  <p><code>BoolIsNotNull</code></p>
  </td>
  <td width=74 valign=top>
  <p><code>ISNOTNULL</code></p>
  </td>
  <td width=99>
  <p>&nbsp;</p>
  </td>
  <td>
  <p>&nbsp;</p>
  </td>
  <td width=38>
  <p align=center>&nbsp;</p>
  </td>
  <td width=38>
  <p align=center>&nbsp;</p>
  </td>
  <td width=38>
  <p align=center>&nbsp;</p>
  </td>
 </tr>
 <tr>
  <td valign=top>
  <p>&nbsp;</p>
  </td>
  <td valign=top>
  <p><code>BoolToNull</code></p>
  </td>
  <td width=74 valign=top>
  <p><code>TONULL</code></p>
  </td>
  <td width=99>
  <p><code>result</code></p>
  </td>
  <td>
  <p>&nbsp;</p>
  </td>
  <td width=38>
  <p align=center>&nbsp;</p>
  </td>
  <td width=38>
  <p align=center>&nbsp;</p>
  </td>
  <td width=38>
  <p align=center>&nbsp;</p>
  </td>
 </tr>
 <tr>
  <td valign=top>
  <p><code><span>··</code><code>NativeNative-Instruction</code></p>
  </td>
  <td valign=top>
  <p><code>NativeAdd</code></p>
  </td>
  <td width=74 valign=top>
  <p><code>ADD</code></p>
  </td>
  <td width=99 rowspan=4 valign=top>
  <p><code>result, operand, operand</code></p>
  </td>
  <td valign=top>
  <p>&nbsp;</p>
  </td>
  <td width=38>
  <p align=center>&nbsp;</p>
  </td>
  <td width=38 colspan=2 rowspan=7>
  <p align=center><code>Y</code></p>
  </td>
  <td width=38>
  <p align=center>&nbsp;</p>
  </td>
 </tr>
 <tr>
  <td valign=top>
  <p>&nbsp;</p>
  </td>
  <td valign=top>
  <p><code>NativeSub</code></p>
  </td>
  <td width=74 valign=top>
  <p><code>SUB</code></p>
  </td>
  <td valign=top>
  <p>&nbsp;</p>
  </td>
  <td width=38>
  <p align=center>&nbsp;</p>
  </td>
  <td width=38>
  <p align=center>&nbsp;</p>
  </td>
 </tr>
 <tr>
  <td valign=top>
  <p>&nbsp;</p>
  </td>
  <td valign=top>
  <p><code>NativeMul</code></p>
  </td>
  <td width=74 valign=top>
  <p><code>MUL</code></p>
  </td>
  <td valign=top>
  <p>&nbsp;</p>
  </td>
  <td width=38>
  <p align=center>&nbsp;</p>
  </td>
  <td width=38>
  <p align=center>&nbsp;</p>
  </td>
 </tr>
 <tr>
  <td valign=top>
  <p>&nbsp;</p>
  </td>
  <td valign=top>
  <p><code>NativeDiv</code></p>
  </td>
  <td width=74 valign=top>
  <p><code>DIV</code></p>
  </td>
  <td valign=top>
  <p>&nbsp;</p>
  </td>
  <td width=38>
  <p align=center>&nbsp;</p>
  </td>
  <td width=38>
  <p align=center>&nbsp;</p>
  </td>
 </tr>
 <tr>
  <td valign=top>
  <p>&nbsp;</p>
  </td>
  <td valign=top>
  <p><code>NativeNeg</code></p>
  </td>
  <td width=74 valign=top>
  <p><code>NEG</code></p>
  </td>
  <td width=99>
  <p><code>result, operand</code></p>
  </td>
  <td valign=top>
  <p>&nbsp;</p>
  </td>
  <td width=38>
  <p align=center>&nbsp;</p>
  </td>
  <td width=38>
  <p align=center>&nbsp;</p>
  </td>
 </tr>
 <tr>
  <td valign=top>
  <p>&nbsp;</p>
  </td>
  <td valign=top>
  <p><code>NativeMove</code></p>
  </td>
  <td width=74 valign=top>
  <p><code>MOVE</code></p>
  </td>
  <td width=99>
  <p>&nbsp;</p>
  </td>
  <td valign=top>
  <p>&nbsp;</p>
  </td>
  <td width=38>
  <p align=center>&nbsp;</p>
  </td>
  <td width=38>
  <p align=center>&nbsp;</p>
  </td>
 </tr>
 <tr>
  <td valign=top>
  <p>&nbsp;</p>
  </td>
  <td valign=top>
  <p><code>NativeToNull</code></p>
  </td>
  <td width=74 valign=top>
  <p><code>TONULL</code></p>
  </td>
  <td width=99>
  <p><code>result</code></p>
  </td>
  <td valign=top>
  <p>&nbsp;</p>
  </td>
  <td width=38>
  <p align=center>&nbsp;</p>
  </td>
  <td width=38>
  <p align=center>&nbsp;</p>
  </td>
 </tr>
 <tr>
  <td valign=top>
  <p><code><span>··</code><code>IntegralNativeInstruction</code></p>
  </td>
  <td valign=top>
  <p><code>IntegralNativeMod</code></p>
  </td>
  <td width=74 valign=top>
  <p><code>MOD</code></p>
  </td>
  <td width=99 valign=top>
  <p><code>result, operand1, operand2</code></p>
  </td>
  <td valign=top>
  <p>modulus operator, op1
  is dividend, op2 is divisor</p>
  </td>
  <td width=38>
  <p align=center>&nbsp;</p>
  </td>
  <td width=38 rowspan=6>
  <p align=center>&nbsp;</p>
  </td>
  <td width=38>
  <p align=center>&nbsp;</p>
  </td>
  <td width=38>
  <p align=center>&nbsp;</p>
  </td>
 </tr>
 <tr>
  <td valign=top>
  <p>&nbsp;</p>
  </td>
  <td valign=top>
  <p><code>IntegralNativeShiftLeft</code></p>
  </td>
  <td width=74 valign=top>
  <p><code>SHFL</code></p>
  </td>
  <td width=99 rowspan=2 valign=top>
  <p><code>result, operand1, operand2</code></p>
  </td>
  <td rowspan=2 valign=top>
  <p>shift operand1 left or
  right by operand2 number of bits. Shifts in zeros. operator2 must be positive
  long or ulong</p>
  </td>
  <td width=38>
  <p align=center>&nbsp;</p>
  </td>
  <td width=38>
  <p align=center>&nbsp;</p>
  </td>
  <td width=38>
  <p align=center>&nbsp;</p>
  </td>
 </tr>
 <tr>
  <td valign=top>
  <p>&nbsp;</p>
  </td>
  <td valign=top>
  <p><code>IntegralNativeShiftRight</code></p>
  </td>
  <td width=74 valign=top>
  <p><code>SHFR</code></p>
  </td>
  <td width=38>
  <p align=center>&nbsp;</p>
  </td>
  <td width=38>
  <p align=center>&nbsp;</p>
  </td>
  <td width=38>
  <p align=center>&nbsp;</p>
  </td>
 </tr>
 <tr>
  <td valign=top>
  <p>&nbsp;</p>
  </td>
  <td valign=top>
  <p><code>IntegralNativeAnd</code></p>
  </td>
  <td width=74 valign=top>
  <p><code>AND</code></p>
  </td>
  <td width=99 rowspan=3 valign=top>
  <p><code>result, operand, operand</code></p>
  </td>
  <td rowspan=2 valign=top>
  <p>Bitwise
  operations</p>
  </td>
  <td width=38>
  <p align=center>&nbsp;</p>
  </td>
  <td width=38>
  <p align=center>&nbsp;</p>
  </td>
  <td width=38>
  <p align=center>&nbsp;</p>
  </td>
 </tr>
 <tr>
  <td valign=top>
  <p>&nbsp;</p>
  </td>
  <td valign=top>
  <p><code>IntegralNativeOr</code></p>
  </td>
  <td width=74 valign=top>
  <p><code>OR</code></p>
  </td>
  <td width=38>
  <p align=center>&nbsp;</p>
  </td>
  <td width=38>
  <p align=center>&nbsp;</p>
  </td>
  <td width=38>
  <p align=center>&nbsp;</p>
  </td>
 </tr>
 <tr>
  <td valign=top>
  <p>&nbsp;</p>
  </td>
  <td valign=top>
  <p><code>IntegralNativeXor</code></p>
  </td>
  <td width=74 valign=top>
  <p><code>XOR</code></p>
  </td>
  <td valign=top>
  <p>No SQL mapping. Dubious
  utility.</p>
  </td>
  <td width=38>
  <p align=center>&nbsp;</p>
  </td>
  <td width=38>
  <p align=center>&nbsp;</p>
  </td>
  <td width=38>
  <p align=center>&nbsp;</p>
  </td>
 </tr>
 <tr>
  <td valign=top>
  <p><code><span>··</code><code>BoolNative-</code><span><br>
  <code>Instruction</code></p>
  </td>
  <td valign=top>
  <p><code>BoolNativeEqual</code></p>
  </td>
  <td width=74 valign=top>
  <p><code>EQ</code></p>
  </td>
  <td width=99 rowspan=6 valign=top>
  <p><code>result, operand, operand</code></p>
  </td>
  <td rowspan=8 valign=top>
  <p>returns boolean</p>
  </td>
  <td width=38>
  <p align=center>&nbsp;</p>
  </td>
  <td width=38 colspan=2 rowspan=8>
  <p>&nbsp;</p>
  </td>
  <td width=38>
  <p align=center>&nbsp;</p>
  </td>
 </tr>
 <tr>
  <td valign=top>
  <p>&nbsp;</p>
  </td>
  <td valign=top>
  <p><code>BoolNativeNotEqual</code></p>
  </td>
  <td width=74 valign=top>
  <p><code>NE</code></p>
  </td>
  <td width=38>
  <p align=center>&nbsp;</p>
  </td>
  <td width=38>
  <p align=center>&nbsp;</p>
  </td>
 </tr>
 <tr>
  <td valign=top>
  <p>&nbsp;</p>
  </td>
  <td valign=top>
  <p><code>BoolNativeGreater</code></p>
  </td>
  <td width=74 valign=top>
  <p><code>GT</code></p>
  </td>
  <td width=38>
  <p align=center>&nbsp;</p>
  </td>
  <td width=38>
  <p align=center>&nbsp;</p>
  </td>
 </tr>
 <tr>
  <td valign=top>
  <p>&nbsp;</p>
  </td>
  <td valign=top>
  <p><code>BoolNativeGreaterEqual</code></p>
  </td>
  <td width=74 valign=top>
  <p><code>GE</code></p>
  </td>
  <td width=38>
  <p align=center>&nbsp;</p>
  </td>
  <td width=38>
  <p align=center>&nbsp;</p>
  </td>
 </tr>
 <tr>
  <td valign=top>
  <p>&nbsp;</p>
  </td>
  <td valign=top>
  <p><code>BoolNativeLess</code></p>
  </td>
  <td width=74 valign=top>
  <p><code>LT</code></p>
  </td>
  <td width=38>
  <p align=center>&nbsp;</p>
  </td>
  <td width=38>
  <p align=center>&nbsp;</p>
  </td>
 </tr>
 <tr>
  <td valign=top>
  <p>&nbsp;</p>
  </td>
  <td valign=top>
  <p><code>BoolNativeLessEqual</code></p>
  </td>
  <td width=74 valign=top>
  <p><code>LE</code></p>
  </td>
  <td width=38>
  <p align=center>&nbsp;</p>
  </td>
  <td width=38>
  <p align=center>&nbsp;</p>
  </td>
 </tr>
 <tr>
  <td valign=top>
  <p>&nbsp;</p>
  </td>
  <td valign=top>
  <p><code>BoolNativeIsNull</code></p>
  </td>
  <td width=74 valign=top>
  <p><code>ISNULL</code></p>
  </td>
  <td width=99 rowspan=2 valign=top>
  <p><code>result, operand</code></p>
  </td>
  <td width=38>
  <p align=center>&nbsp;</p>
  </td>
  <td width=38>
  <p align=center>&nbsp;</p>
  </td>
 </tr>
 <tr>
  <td valign=top>
  <p>&nbsp;</p>
  </td>
  <td valign=top>
  <p><code>BoolNativeIsNotNull</code></p>
  </td>
  <td width=74 valign=top>
  <p><code>ISNOTNULL</code></p>
  </td>
  <td width=38>
  <p align=center>&nbsp;</p>
  </td>
  <td width=38>
  <p align=center>&nbsp;</p>
  </td>
 </tr>
 <tr>
  <td valign=top>
  <p><code><span>··</code><code>PointerPointer-Instruction</code></p>
  </td>
  <td valign=top>
  <p><code>PointerMove</code></p>
  </td>
  <td width=74 valign=top>
  <p><code>MOVE</code></p>
  </td>
  <td width=99 valign=top>
  <p><code>result, operand1</code></p>
  </td>
  <td rowspan=2 valign=top>
  <p>Result and Operand1 are
  pointers.</p>
  <p>Operand2 is Long</p>
  </td>
  <td width=38>
  <p align=center>&nbsp;</p>
  </td>
  <td width=38>
  <p align=center>&nbsp;</p>
  </td>
  <td width=38>
  <p align=center>&nbsp;</p>
  </td>
  <td width=38 rowspan=4>
  <p align=center><code>Y</code></p>
  </td>
 </tr>
 <tr>
  <td valign=top>
  <p>&nbsp;</p>
  </td>
  <td valign=top>
  <p><code>PointerAdd</code></p>
  </td>
  <td width=74 valign=top>
  <p><code>ADD</code></p>
  </td>
  <td width=99 rowspan=2 valign=top>
  <p><code>result, operand1, operand2</code></p>
  </td>
  <td width=38>
  <p align=center>&nbsp;</p>
  </td>
  <td width=38>
  <p align=center>&nbsp;</p>
  </td>
  <td width=38>
  <p align=center>&nbsp;</p>
  </td>
 </tr>
 <tr>
  <td valign=top>
  <p>&nbsp;</p>
  </td>
  <td valign=top>
  <p><code>PointerSub</code></p>
  </td>
  <td width=74 valign=top>
  <p><code>SUB</code></p>
  </td>
  <td rowspan=2>
  <p>&nbsp;</p>
  </td>
  <td width=38>
  <p align=center>&nbsp;</p>
  </td>
  <td width=38>
  <p align=center>&nbsp;</p>
  </td>
  <td width=38>
  <p align=center>&nbsp;</p>
  </td>
 </tr>
 <tr>
  <td valign=top>
  <p>&nbsp;</p>
  </td>
  <td valign=top>
  <p><code>PointerToNull</code></p>
  </td>
  <td width=74 valign=top>
  <p><code>TONULL</code></p>
  </td>
  <td width=99 valign=top>
  <p><code>result</code></p>
  </td>
  <td width=38>
  <p align=center>&nbsp;</p>
  </td>
  <td width=38>
  <p align=center>&nbsp;</p>
  </td>
  <td width=38>
  <p align=center>&nbsp;</p>
  </td>
 </tr>
 <tr>
  <td valign=top>
  <p><code><span>··</code><code>BoolPointer-Instruction</code></p>
  </td>
  <td valign=top>
  <p><code>PointerEqual</code></p>
  </td>
  <td width=74 valign=top>
  <p><code>EQ</code></p>
  </td>
  <td width=99 rowspan=6 valign=top>
  <p><code>result, operand, operand</code></p>
  </td>
  <td rowspan=8 valign=top>
  <p>returns boolean</p>
  </td>
  <td width=38>
  <p align=center>&nbsp;</p>
  </td>
  <td width=38 colspan=2 rowspan=8>
  <p>&nbsp;</p>
  </td>
  <td width=38>
  <p align=center>&nbsp;</p>
  </td>
 </tr>
 <tr>
  <td valign=top>
  <p>&nbsp;</p>
  </td>
  <td valign=top>
  <p><code>PointerNotEqual</code></p>
  </td>
  <td width=74 valign=top>
  <p><code>NE</code></p>
  </td>
  <td width=38>
  <p align=center>&nbsp;</p>
  </td>
  <td width=38>
  <p align=center>&nbsp;</p>
  </td>
 </tr>
 <tr>
  <td valign=top>
  <p>&nbsp;</p>
  </td>
  <td valign=top>
  <p><code>PointerGreater</code></p>
  </td>
  <td width=74 valign=top>
  <p><code>GT</code></p>
  </td>
  <td width=38>
  <p align=center>&nbsp;</p>
  </td>
  <td width=38>
  <p align=center>&nbsp;</p>
  </td>
 </tr>
 <tr>
  <td valign=top>
  <p>&nbsp;</p>
  </td>
  <td valign=top>
  <p><code>PointerGreaterEqual</code></p>
  </td>
  <td width=74 valign=top>
  <p><code>GE</code></p>
  </td>
  <td width=38>
  <p align=center>&nbsp;</p>
  </td>
  <td width=38>
  <p align=center>&nbsp;</p>
  </td>
 </tr>
 <tr>
  <td valign=top>
  <p>&nbsp;</p>
  </td>
  <td valign=top>
  <p><code>PointerLess</code></p>
  </td>
  <td width=74 valign=top>
  <p><code>LT</code></p>
  </td>
  <td width=38>
  <p align=center>&nbsp;</p>
  </td>
  <td width=38>
  <p align=center>&nbsp;</p>
  </td>
 </tr>
 <tr>
  <td valign=top>
  <p>&nbsp;</p>
  </td>
  <td valign=top>
  <p><code>PointerLessEqual</code></p>
  </td>
  <td width=74 valign=top>
  <p><code>LE</code></p>
  </td>
  <td width=38>
  <p align=center>&nbsp;</p>
  </td>
  <td width=38>
  <p align=center>&nbsp;</p>
  </td>
 </tr>
 <tr>
  <td valign=top>
  <p>&nbsp;</p>
  </td>
  <td valign=top>
  <p><code>PointerIsNull</code></p>
  </td>
  <td width=74 valign=top>
  <p><code>ISNULL</code></p>
  </td>
  <td width=99 rowspan=2 valign=top>
  <p><code>result,</code></p>
  <p><code>operand</code></p>
  </td>
  <td width=38>
  <p align=center>&nbsp;</p>
  </td>
  <td width=38>
  <p align=center>&nbsp;</p>
  </td>
 </tr>
 <tr>
  <td valign=top>
  <p>&nbsp;</p>
  </td>
  <td valign=top>
  <p><code>PointerIsNotNull</code></p>
  </td>
  <td width=74 valign=top>
  <p><code>ISNOTNULL</code></p>
  </td>
  <td width=38>
  <p align=center>&nbsp;</p>
  </td>
  <td width=38>
  <p align=center>&nbsp;</p>
  </td>
 </tr>
 <tr>
  <td valign=top>
  <p><code><span>·</code><code>JumpInstruction</code></p>
  </td>
  <td valign=top>
  <p><code>Jump</code></p>
  </td>
  <td width=74 valign=top>
  <p><code>JMP</code></p>
  </td>
  <td width=99 valign=top>
  <p><code>location</code></p>
  </td>
  <td valign=top>
  <p>unconditional jump</p>
  </td>
  <td width=38>
  <p align=center>&nbsp;</p>
  </td>
  <td width=38>
  <p align=center>&nbsp;</p>
  </td>
  <td width=38>
  <p align=center>&nbsp;</p>
  </td>
  <td width=38>
  <p align=center>&nbsp;</p>
  </td>
 </tr>
 <tr>
  <td valign=top>
  <p>&nbsp;</p>
  </td>
  <td valign=top>
  <p><code>JumpTrue</code></p>
  </td>
  <td width=74 valign=top>
  <p><code>JMPT</code></p>
  </td>
  <td width=99 rowspan=4 valign=top>
  <p><code>location, operand</code></p>
  </td>
  <td rowspan=4 valign=top>
  <p>conditional jump,
  operand is boolean</p>
  </td>
  <td width=38 rowspan=4>
  <p align=center><code>Y</code></p>
  </td>
  <td width=38>
  <p align=center>&nbsp;</p>
  </td>
  <td width=38>
  <p align=center>&nbsp;</p>
  </td>
  <td width=38>
  <p align=center>&nbsp;</p>
  </td>
 </tr>
 <tr>
  <td valign=top>
  <p>&nbsp;</p>
  </td>
  <td valign=top>
  <p><code>JumpFalse</code></p>
  </td>
  <td width=74 valign=top>
  <p><code>JMPF</code></p>
  </td>
  <td width=38>
  <p align=center>&nbsp;</p>
  </td>
  <td width=38>
  <p align=center>&nbsp;</p>
  </td>
  <td width=38>
  <p align=center>&nbsp;</p>
  </td>
 </tr>
 <tr>
  <td valign=top>
  <p>&nbsp;</p>
  </td>
  <td valign=top>
  <p><code>JumpNull</code></p>
  </td>
  <td width=74 valign=top>
  <p><code>JMPN</code></p>
  </td>
  <td width=38>
  <p align=center>&nbsp;</p>
  </td>
  <td width=38>
  <p align=center>&nbsp;</p>
  </td>
  <td width=38>
  <p align=center>&nbsp;</p>
  </td>
 </tr>
 <tr>
  <td valign=top>
  <p>&nbsp;</p>
  </td>
  <td valign=top>
  <p><code>JumpNotNull</code></p>
  </td>
  <td width=74 valign=top>
  <p><code>JMPNN</code></p>
  </td>
  <td width=38>
  <p align=center>&nbsp;</p>
  </td>
  <td width=38>
  <p align=center>&nbsp;</p>
  </td>
  <td width=38>
  <p align=center>&nbsp;</p>
  </td>
 </tr>
 <tr>
  <td valign=top>
  <p><code><span>·</code><code>Instruction</code></p>
  </td>
  <td valign=top>
  <p><code>Raise</code></p>
  </td>
  <td width=74 valign=top>
  <p><code>RAISE</code></p>
  </td>
  <td width=99 valign=top>
  <p><code>literal long</code></p>
  </td>
  <td valign=top>
  <p>Exception. Operands TBD</p>
  </td>
  <td width=38>
  <p align=center>&nbsp;</p>
  </td>
  <td width=38>
  <p align=center>&nbsp;</p>
  </td>
  <td width=38>
  <p align=center>&nbsp;</p>
  </td>
  <td width=38>
  <p align=center>&nbsp;</p>
  </td>
 </tr>
 <tr>
  <td valign=top>
  <p><code><span>·</code><code>Instruction</code></p>
  </td>
  <td valign=top>
  <p><code>Return</code></p>
  </td>
  <td width=74 valign=top>
  <p><code>RETURN</code></p>
  </td>
  <td width=99 valign=top>
  <p>&nbsp;</p>
  </td>
  <td valign=top>
  <p>Exit from Calculator.
  Operand TBD</p>
  </td>
  <td width=38>
  <p align=center>&nbsp;</p>
  </td>
  <td width=38>
  <p align=center>&nbsp;</p>
  </td>
  <td width=38>
  <p align=center>&nbsp;</p>
  </td>
  <td width=38>
  <p align=center>&nbsp;</p>
  </td>
 </tr>
 <tr>
  <td valign=top>
  <p><code><span>·</code><code>ExtendedInstruction</code></p>
  </td>
  <td valign=top>
  <p><code>ExtendedInstruction</code></p>
  </td>
  <td width=74 valign=top>
  <p><code>EXT</code></p>
  </td>
  <td width=99 valign=top>
  <p><code>signature</code></p>
  </td>
  <td valign=top>
  <p>Signature is a string: <br>
  &#8220;Fname(type1,type2,type3)&#8221; </p>
  </td>
  <td width=38>
  <p align=center><code>?</code></p>
  </td>
  <td width=38>
  <p align=center><code>Y</code></p>
  </td>
  <td width=38>
  <p align=center><code>Y</code></p>
  </td>
  <td width=38>
  <p align=center><code>Y</code></p>
  </td>
 </tr>
 <tr>
  <td valign=top>
  <p><code>CalInstruction</code></p>
  </td>
  <td valign=top>
  <p><code>Call</code></p>
  </td>
  <td width=74 valign=top>
  <p><code>CALL</code></p>
  </td>
  <td width=99 valign=top>
  <p><code>TBD</code></p>
  </td>
  <td valign=top>
  <p>TBD</p>
  </td>
  <td width=38>
  <p align=center><code>?</code></p>
  </td>
  <td width=38>
  <p align=center><code>Y</code></p>
  </td>
  <td width=38>
  <p align=center><code>Y</code></p>
  </td>
  <td width=38>
  <p align=center><code>Y</code></p>
  </td>
 </tr>
</table>

<h1>Assembler</h1>

<p>The Assembler performs the following functions:</p>

<ul type=disc>
 <li>Creates
     Output, Literal, Local and Status Tuples.</li>
 <li>Binds
     Literal, Local and Status Tuples to Calculator Register sets.</li>
 <li>Initializes
     literal values in Literal Register Set.</li>
 <li>Verifies
     the format of serialized programs as they are parsed, including type
     checking.</li>
 <li>Converts
     (&#8220;assembles&#8221;) serialized programs (string representation of programs) into
     instruction objects.</li>
</ul>

<h2>Serialized Programs</h2>

<p>Serialized programs support the following features:</p>

<ul type=disc>
 <li>A
     preamble that defines the size and shape of all register sets. This
     information is effectively a tuple definition for each register set.</li>
 <li>A
     preamble that optionally contains literals to be initialized in the
     literal register set.</li>
 <li>Support
     for all types of literals, including 8-bit arrays VARBINARY, Unicode strings,
     etc in a 6-bit clean manner.</li>
 <li>A
     list of instructions, the actual program text, to be created and inserted
     into the Calculator</li>
</ul>

<h3>XML Format</h3>

<p>For any number of good reasons, Calculator should support
XML representations of programs. Unfortunately, an XML representation
introduces the requirement for an XML parser into Fennel, which is not strictly
necessary for Calculator to work. Therefore, to avoid adding another library
dependency on Fennel, the text representation of programs will not be XML.</p>

<h3>Boost::Spirit Parser</h3>

<p>This parser was considered, but eventually disregarded. The
template programming style that Spirit is written in is appealing, but contains
a steep learning curve. Maintenance of this parser could be difficult. Also,
compile-time errors are rather difficult to decode at times. The developer
might be forced to only make small changes, and then compile and test.
Otherwise it can be nearly impossible to tell where an error was introduced.
Perhaps the Spirit parser can be re-investigated in the future.</p>

<h3>Simple Serialized Format</h3>

<p>All of the functionality required can be provided cheaply by
using a very simple format to represent instructions. Expediency is the goal
for now. The implementation details of this parser are, at the moment, outside
the scope of this document. If the parser introduces an additional library
dependency to Fennel, it must be possible to compile Fennel without the parser.
For example, fennel/configure should take arguments, similar to <code>&#8211;with-boost&#8211;with-stlport</code>, such as
&#8211;with-ANTLR &#8211;with-XERCES</code>, or the like, to enable serial program
representation and the associated third-party parsing library.</p>

<h3>BNF (EBNF?) of Simple Serialized Format</h3>

<p>&nbsp;</p>

<p>Note: &lt; whitespace &gt; is allowed between tokens.
Tokenizer or skip-parser should consume &lt; whitespace &gt;</p>

<p>Note: Format is case-sensitive.</p>

<p>&nbsp;</p>

<blockquote><code>

	&lt; whitespace &gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ::= &#8220; &#8220; | &#8220;\n&#8221;
| &#8220;\r&#8221; | &#8220;\t&#8221;<br/>

	<br/>

	&lt; program &gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ::=
&lt;preamble&gt; &#8220;T&#8221; &lt; program text &gt;<br/>

	<br/>

	&lt; preamble &gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ::= &lt; registerset def
&gt; [ &lt;literal set def &gt; &lt; literal values &gt; ]<br/>

	<br/>

	&lt; registerset def &gt; ::= &lt; set name
&gt; <br/>

	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[ &#8220;,&#8221; ( &lt; type size &gt; )+ ]<br/>

	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&lt; terminator &gt;<br/>

	&lt; set name &gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ::= &#8220;O&#8221; | # Output<br/>

	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&#8220;I&#8221; | # Input &#8211; Generally unused.<br/>

	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&#8220;S&#8221; | # Status<br/>

	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#8220;L&#8221; | # Local <br/>

	<br/>

	&lt; type size &gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ::= { &lt; fixedlengthtype
&gt; } |<br/>

	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
{ &lt; variablelengthtype &gt; &#8220;,&#8221; &lt; bytes &gt; }<br/>

	<br/>

	&lt; fixedlengthtype &gt; ::= &lt; integers
&gt; |<br/>

	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&lt; reals &gt; |<br/>

	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&lt; doubles &gt; | <br/>

	&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;
chars &gt; | <br/>

	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&lt; binary &gt;<br/>

	<br/>

	&lt; variablelengthtype &gt;:: = &lt; varchar
&gt; | &lt; varbinary &gt;<br/>

	<br/>

	&lt; literal set def &gt; ::= &#8220;C&#8221;&nbsp;&nbsp; # Literal set, think Constant.<br/>

	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[ &#8220;,&#8221; ( &lt; type size &gt; )+ ]<br/>

	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt; terminator &gt;<br/>

	<br/>

	&lt; literal values &gt;&nbsp; ::= &#8220;V&#8221;&nbsp;&nbsp;&nbsp; # Values<br/>

	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
( &lt; literal def&gt; ) *<br/>

	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&lt; terminator &gt;<br/>

	<br/>

	&lt; literal def &gt;&nbsp;&nbsp;&nbsp;&nbsp; ::= &lt; integerval
&gt; | <br/>

	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&lt; realval &gt; | <br/>

	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&lt; bytearrayval &gt;<br/>

	<br/>

	&lt; integerval &gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ::= [ &#8220;-&#8220; ]<br/>

	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
( [0-9] ) +<br/>

	<br/>

	&lt; realval &gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ::= [ &#8220;-&#8220; ]<br/>

	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
( [0-9] ) + <br/>

	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&#8220;.&#8221;<br/>

	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
( [0-9] ) + <br/>

	<br/>

	&lt; bytearrayval&gt;&nbsp;&nbsp;&nbsp;&nbsp; ::=&nbsp; # TBD See section &#8220;Binary Encoding&#8221;<br/>

	<br/>

	&lt; program text &gt;&nbsp;&nbsp;&nbsp; ::= ( &lt; instruction &gt;
) +&nbsp;&nbsp; # a program has 1 or
more instructions<br/>

	<br/>

	&lt; instruction &gt;&nbsp;&nbsp;&nbsp;&nbsp; ::=&nbsp; &lt; opcode &gt; &#8220;,&#8221;<br/>

	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&lt; operand list &gt;<br/>

	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&lt; terminator &gt; <br/>

	<br/>

	&lt; operand list &gt;&nbsp;&nbsp;&nbsp; ::= { &lt; result &gt; &#8220;,&#8221;
&lt; operand &gt; [ &#8220;,&#8221; &lt; operand &gt; ] } |<br/>

	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
{ &lt; set size &gt; } <br/>

	<br/>

	&lt; terminator &gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :: = &#8220;;&#8221;<br/>

	<br/>

	&lt; result &gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ::= &lt;
output address &gt; |<br/>

	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&lt; local address &gt;<br/>

	<br/>

	&lt; operand &gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ::= &lt; output
address &gt; | <br/>

	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&lt; input address &gt; | <br/>

	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&lt; local address &gt; | <br/>

	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&lt; literal address &gt; | <br/>

	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&lt; status address &gt; |<br/>

	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&lt; instruction address &gt;<br/>

	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; /* &lt; SIB address
&gt; */<br/>

	<br/>

	&lt; output address &gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ::= &#8220;O&#8221;<br/>

	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&lt; type &gt;<br/>

	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&lt; whitespace &gt;<br/>

	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&lt; output index &gt;<br>
	<br/>

	&lt; input address &gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ::= &#8220;I&#8221; 
	<br/>

	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&lt; type &gt;<br/>

	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;
whitespace &gt;<br/>

	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&lt; input index &gt; <br>
	<br/>

	&lt; local address &gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ::= &#8220;L&#8221; 
	<br/>

	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&lt; type &gt;<br/>

	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&lt; whitespace &gt;<br/>

	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&lt; memory index &gt;<br>
	<br/>

	&lt; literal address &gt;&nbsp;&nbsp;&nbsp;&nbsp; ::= &#8220;C&#8221;<br/>

	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&lt; type &gt;<br/>

	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&lt; whitespace &gt; <br/>

	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&lt; literal index &gt;<br>
	<br/>

	&lt; status address &gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ::= &#8220;S&#8221; 
	<br/>

	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&lt; type &gt;<br/>

	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&lt; whitespace &gt;<br/>

	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;
literal index &gt;<br>
	<br/>

	&lt; instruction address &gt; ::= &#8220;@&#8221;
&lt;instruction index &gt;<br/>

	<br/>

	/* &lt; SIB address &gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ::= &#8220;*&#8221; &lt;
type &gt; &lt; scale &gt; &#8220;,&#8221; &lt; index &gt; &#8220;,&#8221; &lt; base &gt; */<br/>

	<br/>

	&lt; type &gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
::= &lt; assembly code type &gt; <br/>

	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
# see Types section &amp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
	# StandardTypeToString<br/>

	<br/>

	&lt; set size &gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;::= &lt; output index &gt; | 
	<br/>

	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&lt; input index&gt; | <br/>

	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&lt; local index&gt; |<br/>

	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&lt; literal index &gt; |<br/>

	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&lt; status index &gt;<br/>

	<br/>

	&lt; output index &gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ::=
0 | 1 | ... | &lt;size of output register set &#8211; 1&gt;<br/>

	&lt; input index &gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
::= 0 | 1 | ... | &lt;size of input register set &#8211; 1&gt;<br/>

	&lt; local index &gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
::= 0 | 1 | ... | &lt;size of local register set &#8211; 1&gt;<br/>

	&lt; literal index &gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ::= 0 | 1
| ... | &lt;size of literal register set &#8211; 1&gt;<br/>

	&lt; status index &gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ::=
0 | 1 | ... | &lt;size of status register set &#8211; 1&gt;<br/>

	<br/>

	&lt; instruction index &gt;&nbsp;&nbsp; ::= 0 | 1 | . . . | &lt;size of
program &#8211; 1&gt;<br/>

</code></blockquote>

<p>Note: May want additional <code>&lt; literal def &gt;</code> definitions,
for example exponents: 6.0221 * 10^24. <b>TBD</b></p>

<h3>Array Encoding</h3>

<p>Character arrays (strings) and binary arrays will be encoded
to allow transmission and viewing in less than 8-bit clean environments.
Typically strings passed through the calculator will be encoded with Unicode
and will therefore contain many non-printable (at least when interpreted as
ASCII) characters. The format must also support the initialization of VARBINARY
and other explicitly binary types, even though their use is likely to be
somewhat rare.</p>

<p>Design goals, in rough order are:</p>

<ol>
	<li>CPU Utilization</li>
	<li>Size Inflation</li>
	<li>Hand Decoding</li>
	<li>Human Readable</li>
</ol>

<p>Candidate encoding schemes include, but are not limited to: </p>

<ol>
	<li>Base64</li>
	<li>Hex (each byte represented by two characters)</li>
	<li>BinHex-like (minus the resource fork features)</li>
	<li>Escaped, yet printable-ASCII.</li>
</ol>

<p>ENCODING FORMAT IS <b>TBD</b>.</p>

<h3>Example Programs</h3>

<p>The following is a list of SQL statements and statement
fragments and corresponding example compilations of those statements into
Calculator programs. More efficient representations of the statements certainly
exist. This list is not intended as a guide to the most efficient
representation, rather as a possible representation.</p>

<blockquote>

	<p><code>CREATE TABLE COURSE (<br>
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Heading INT,<br>
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; COG INT,<br>
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VMG REAL);</code></p>

	<p><code>SELECT COG - Heading as Set<br>
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FROM COURSE<br>
	&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WHERE ( (Heading &gt; 200 AND Heading
&lt; 220)<br>
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
OR<br>
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
VMG &gt; 10.0)<br>
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
);&nbsp;</code></p>

	<p><code>I s4, s4, r;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
# Input Register Set is:<br>
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
#&nbsp;&nbsp; 0: long
&quot;Heading&quot;, 1: long &quot;COG&quot;<br>
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
# &nbsp;&nbsp;2: real
&quot;VMG&quot;<br>
	O s4;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
# Output&nbsp; Register Set:<br>
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
#&nbsp;&nbsp; 0: long
&quot;Set&quot;<br>
	S u1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
# Status Register Set: unsigned char;<br>
	C u1, u1, u1, u1, u1, u4;&nbsp; # Local Register Set: 5 booleans,<br>
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;&nbsp; represented by unsigned chars<br>
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
#&nbsp;&nbsp; and on s4
&quot;Set&quot;<br>
	L u1, u1, s4, s4, r;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Literal
Register Set:<br>
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
#&nbsp;&nbsp; boolean, boolean,
long,<br>
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
#&nbsp;&nbsp; long, real;<br>
	V 1, 0, 200, 220, 10.0;&nbsp;&nbsp;&nbsp; # Values for Literal
Register Set,<br>
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
#&nbsp;&nbsp; including a TRUE
and FALSE<br>
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
# Following could be done more<br>
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
#&nbsp;&nbsp; efficently. Drawing
out the example<br>
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
#&nbsp;&nbsp; here on purpose:<br>
	T;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
# Start program text<br>
	GT&nbsp;&nbsp; L u1 0, I s4 0, C s4 2;&nbsp; #00# Heading &gt; 200, store result bool in local 0<br>
	LT&nbsp;&nbsp; L u1 1, I s4 1, C s4 3;&nbsp; #01# Heading &lt; 220, store result bool in local 1<br>
	AND&nbsp;
L u1 2, L u1 0, L u1 1;&nbsp;
#02# AND local 0 and local 1, result in local 2<br>
	GT&nbsp;&nbsp; L u1 3, I r&nbsp;
3, C r&nbsp; 4;&nbsp; #03# VMG &gt; 10.0, result in local 3<br>
	OR&nbsp;&nbsp; L u1 4, L u1 2, L u1 3;&nbsp; #04# OR result of AND and SOG &gt; 10.0<br>
	JMPT @ 8&nbsp;&nbsp; , L u1 4;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #05# Jump if
WHERE is satisfied<br>
	MOVE S u1 0, C u1 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #06# Move
Literal[0] &quot;TRUE&quot; to<br>
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
#&nbsp;&nbsp;&nbsp; Status[0].
Filter this row.<br>
	RETURN;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
#07# Exit, filtering row.<br>
	SUB&nbsp;
O s4 0, I s4 1, I s4 0;&nbsp;
#08# Subtract Input[0] from Input[1],<br>
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;&nbsp;&nbsp; into Output[0]<br>
	MOVE S u1 0, L u1 1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #09# Move
Literal[0] &quot;FALSE&quot; to<br>
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
#&nbsp;&nbsp;&nbsp; Status[0]. Do
not filter this row.<br>
	RETURN;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
#10# Exit, passing row onward.</code></p>
</blockquote>

<p>&nbsp;</p>

<h3>MORE EXAMPLES TO FOLLOW IN THIS SPACE</h3>

<p>For completeness, a demonstration that the language can
perform more complex algorithms, handle iteration, etc. Also, an argument for
an indexing addressing mode:</p>

<blockquote>

	<p><code>// Fibonacci<br>
	input(long 0) = n, n&gt;=2;<br>
	<br>
	long prev, temp, curr, count<br>
	ulong index;<br>
	prev = 1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
mem(0)<br>
	curr = 1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
mem(1)<br>
	index = 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // mem(2)<br>
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// count mem(3)<br>
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// temp mem(4)<br>
	out(index++) = prev;<br>
	out(index++) = curr;<br>
	for (count = 0; count &lt; input(0); count++)
{<br>
	&nbsp;&nbsp;&nbsp;&nbsp; temp
= curr;<br>
	&nbsp;&nbsp;&nbsp;&nbsp; curr
= curr + prev;<br>
	&nbsp;&nbsp;&nbsp;&nbsp; out(index++)
= curr; <br>
	&nbsp;&nbsp;&nbsp;&nbsp; prev
= temp;<br>
	}</code></p>
</blockquote>

<p>Example register set layout:</p>

<blockquote>

	<p><code>inputs:&nbsp;&nbsp; [0] = n<br>
	literals: [0] = long 0, [1] = long 1, [2] =
ulong 0;<br>
	locals:&nbsp;&nbsp; [0] = prev, [1] = curr, [2] = index, [3] = count, [4]
= temp</code></p>
</blockquote>

<p>Program:</p>

<blockquote>

	<p><code>(Note: Has not been updated to current
instruction set.)<br>
	MOVE&nbsp;&nbsp; &amp;0, % long 1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// prev = 1<br>
	MOVE&nbsp;&nbsp; &amp;1, % long 1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// curr = 1<br>
	MOVE&nbsp;&nbsp; &amp;2, % ulong 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
index = 0<br>
	MOVEI&nbsp;
#0, &amp; long 0, &amp;2;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // note: index is
implicitly ulong in 3rd operand.<br>
	ADD&nbsp;&nbsp;&nbsp; &amp;2, &amp; ulong 2, %ulong 1; // note: side
effect! Read Opands read before writeback.<br>
	MOVEI&nbsp;
#0, &amp; long 0, &amp;2;<br>
	ADD&nbsp;&nbsp;&nbsp; &amp;2, &amp; ulong 2, %ulong 1; // an inc
operator might be nice, but would be redundant<br>
	MOVE&nbsp;&nbsp; &amp;3, % long 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// count = 0<br>
	_BEGINLOOP;<br>
	JMPGE&nbsp;
_ENDLOOP, &amp; long 3, $ long 0;<br>
	MOVE&nbsp;&nbsp; &amp;4, &amp; long 1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// temp = cur<br>
	ADD&nbsp;&nbsp;&nbsp; &amp;1, &amp; long 1, &amp; long 0;&nbsp;&nbsp;&nbsp; // curr = curr + prev<br>
	MOVEI&nbsp;
#0, &amp; long 0, &amp;2;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
out(index) = curr<br>
	ADD&nbsp;&nbsp;&nbsp; &amp;2, &amp; ulong 2, % ulong 1;&nbsp; // index++<br>
	MOVE&nbsp;&nbsp; &amp;0, &amp; long 4;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// prev = temp<br>
	ADD&nbsp;&nbsp;&nbsp; &amp;3, &amp; long 3, % long 1;&nbsp;&nbsp;&nbsp; // count++<br>
	JUMP&nbsp;&nbsp; _BEGINLOOP;<br>
	_ENDLOOP;<br>
	RETURN;</code></p>
</blockquote>

<h1>Object Tree</h1>

<p>The design goal is to group classes first by type then by
operation to allow base classes to be templated by type. Better combinatorics
for integral types this way.</p>

<p>Please excuse this diagram represented as an outline.</p>

<p>Outline gude:</p>

<p>Object : Base Class</p>

<p>contains</p>

<p>contains</p>

<p>[&#8230;]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </p>

<p>Member Function ()</p>

<p>Member Function ()</p>

<p>[&#8230;]</p>

<p>&nbsp;</p>

<p><code>Calculator</code></p>

<h5><code>Code</code></h5>

<p><code>Program
counter</code></p>

<p><code>Registers</code></p>

<p><code>&nbsp;</code></p>

<p><code>Register Reference</code></p>
<ul>
	<li><code>Register
Set Index</code></li>
	<li><code>Register
Index</code></li>
	<li><code>Pointer</code></li>
</ul>

<p><code>Registers</code></p>

<ul>
	<li><code>Input
Register Set</code></li>
	<li><code>Output
Register Set</code></li>
	<li><code>Local
Register Set</code></li>
	<li><code>Literal
Register Set</code></li>
	<li><code>Status
Register Set</code></li>
</ul>

<p><code>Instruction</code></p>
<ul>
	<li><code>longName()
pure virtual</code></li>
	<li><code>shortName()
pure virtual</code></li>
	<li><code>describe()
pure virtual</code></li>
	<li><code>exec()
pure virtual private (called from friend class Calculator)</code></li>
	<li><code>bindCalc()
pure virtual</code></li>
</ul>

<p>&nbsp;</p>
<ul>
	<li><code>BoolInstruction
: Instruction&nbsp;</code><ul>
		<li><code>BoolOr
: BoolInstruction</code></li>
		<li><code>BoolAnd
: BoolInstruction</code></li>
		<li>

		<p class=MsoHeading7><code>BoolNot
: BoolInstruction</code></p></li>
		<li><code>BoolMove
: BoolInstruction</code></li>
		<li><code>BoolEqual
: BoolInstruction</code></li>
		<li><code>BoolNotEqual
: BoolInstruction</code></li>
		<li><code>BoolLess
: BoolInstruction</code></li>
		<li><code>BoolGreater
: BoolInstruction</code></li>
		<li><code>BoolIsNull
: BoolInstruction</code></li>
		<li><code>BoolNotNull
: BoolInstruction</code></li>
	</ul></li>
	<li><code>NativeInstruction
&lt;T&gt; : Instruction</code><ul>
		<li><code>NativeNativeInstruction
&lt;T&gt; : NativeInstruction</code><ul>
			<li>

			<p class=MsoHeading9><code>NativeAdd
&lt;T&gt; : NativeNativeInstruction // Concrete</code></p></li>
			<li><code>NativeSub
&lt;T&gt; : NativeNativeInstruction // Concrete</code></li>
			<li><code>NativeMul
&lt;T&gt; : NativeNativeInstruction // Concrete</code></li>
			<li><code>NativeDiv
&lt;T&gt; : NativeNativeInstruction // Concrete</code></li>
			<li><code>NativeNeg
&lt;T&gt; : NativeNativeInstruction // Concrete</code></li>
			<li><code>NativeMove
&lt;T&gt; : NativeNativeInstruction // Concrete</code></li>
		</ul></li>
		<li><code>IntegralNativeInstruction
&lt;T&gt; : NativeInstruction</code><ul>
			<li><code>IntegralNativeMod
&lt;T&gt; : IntegralNativeInstruction&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Concrete</code></li>
			<li><code>IntegralNativeAnd
&lt;T&gt; : IntegralNativeInstruction&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Concrete</code></li>
			<li><code>IntegralNativeOr
&lt;T&gt; : IntegralNativeInstruction&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
Concrete</code></li>
			<li><code>IntegralNativeShiftLeft
&lt;T&gt; : IntegralNativeInstruction&nbsp;&nbsp;&nbsp; // Concrete</code></li>
			<li><code>IntegralNativeShiftRight
&lt;T&gt; : IntegralNativeInstruction&nbsp;&nbsp; // Concrete</code></li>
		</ul></li>
		<li><code>BoolNativeInstruction
&lt;T&gt; : NativeInstruction</code>
		<ul>
			<li>

			<p class=MsoBodyTextIndent3><code>BoolNativeEqual
&lt;T&gt; : BoolNativeInstruction&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Concrete</code></p>
			</li>
			<li><code>BoolNativeNotEqual
&lt;T&gt; : BoolNativeInstruction&nbsp;&nbsp;&nbsp;&nbsp; // Concrete</code></li>
			<li><code>BoolNativeGreater
&lt;T&gt; : BoolNativeInstruction&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Concrete</code></li>
			<li><code>BoolNativeGreaterEqual
&lt;T&gt; : BoolNativeInstruction // Concrete</code></li>
			<li><code>BoolNativeLess
&lt;T&gt; : BoolNativeInstruction&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Concrete</code></li>
			<li><code>BoolNativeLessEqual
&lt;T&gt; : BoolNativeInstruction&nbsp;&nbsp;&nbsp; // Concrete</code></li>
			<li><code>BoolNativeIsNull
&lt;T&gt; : BoolNativeInstruction&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Concrete</code></li>
			<li><code>BoolNativeNotNull
&lt;T&gt; : BoolNativeInstruction&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Concrete</code>
			</li>
		</ul></li>
	</ul></li>
	<li><code>PointerInstruction
&lt;T&gt; : Instruction</code><ul>
		<li><code>PointerPointerInstruction
&lt;T&gt; : PointerInstruction</code><ul>
			<li><code>PointerMove &lt;T&gt; :
PointerInstruction&nbsp; // Concrete</code></li>
			<li><code>PointerAdd
&lt;T&gt; : PointerInstruction&nbsp;&nbsp;
// Concrete</code></li>
			<li><code>PointerSub
&lt;T&gt; : PointerInstruction&nbsp;&nbsp;
// Concrete</code></li>
			<li><code>PointerToNull
&lt;T&gt; : PointerInstruction&nbsp;&nbsp;
// Concrete</code></li>
		</ul></li>
		<li><code>BoolPointerInstruction
&lt;T&gt; : PointerInstruction</code></li>
		<li><code>PointerEqual &lt;T&gt;
: PointerInstruction&nbsp; // Concrete</code></li>
		<li><code>PointerNotEqual
&lt;T&gt; : PointerInstruction&nbsp;&nbsp;
// Concrete</code></li>
		<li><code>PointerGreater
&lt;T&gt; : PointerInstruction&nbsp;&nbsp;
// Concrete</code></li>
		<li><code>PointerGreaterEqual
&lt;T&gt; : PointerInstruction&nbsp;&nbsp;
// Concrete</code></li>
		<li><code>PointerLess
&lt;T&gt; : PointerInstruction&nbsp;&nbsp;
// Concrete</code></li>
		<li><code>PointerLessEqual &lt;T&gt; : PointerInstruction&nbsp;&nbsp; // Concrete</code></li>
		<li><code>PointerIsNull
&lt;T&gt; : PointerInstruction&nbsp;&nbsp;
// Concrete</code></li>
		<li><code>PointerIsNotNull &lt;T&gt; : PointerInstruction&nbsp;&nbsp; // Concrete</code></li>
	</ul></li>
	<li><code>JumpInstruction
: Instruction</code><ul>
		<li><code>Jump
: FlowInstruction&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Concrete</code></li>
		<li><code>JumpTrue:
FlowInstruction&nbsp;&nbsp;&nbsp;&nbsp;
// Concrete</code></li>
		<li><code>JumpFalse:
FlowInstruction&nbsp;&nbsp;&nbsp; //
Concrete</code></li>
		<li><code>JumpNull:
FlowInstruction&nbsp;&nbsp;&nbsp;&nbsp;
// Concrete</code></li>
		<li><code>JumpNotNull:
FlowInstruction&nbsp; // Concrete</code></li>
	</ul></li>
	<li><code>ReturnInstruction
: Instruction&nbsp;&nbsp;&nbsp; //
Concrete</code></li>
	<li><code>ReturnException
: Instruction&nbsp;&nbsp;&nbsp; //
Concrete</code></li>
	<li><code>CallInstruction
: Instruction </code></li>
</ul>

<p><b>TBD</b></p>

<p><code>&nbsp;</code></p>

<p>&nbsp;</p>

<h1>Miscellaneous Topics</h1>

<h2>Programming Conventions</h2>

<h3>General Conventions</h3>

<ul type=disc>
 <li>Avoid
     writing into Literal register set. This may be enforced with the <code>ReadOnly</code> RegisterReference
     property.</li>
 <li>Writing
     into Local register set is strictly forbidden. XOs and the tuple
     unmarshalling code make assumptions that the underlying tuple will not be
     molested. This may be enforced with the <code>ReadOnly</code>
     RegisterReference property.</li>
 <li>Program
     should explicitly clear status registers.</li>
 <li>XO
     should check the warning from Calculator after each execution</li>
</ul>

<h3>Aggregation &amp; Analytic Functions</h3>

<p>SQL <b>Aggregate Functions </b>and <b>Analytic Functions</b>
can be supported by the program writer by appropriate manipulation of Output
register sets. The &#8220;aggregator buckets&#8221; (nee accumulators) would be modeled as
Output sets that were passed to various Calculators. There is no requirement
that Output sets be cleared before use. Reading from Output registers is legal
and encouraged. Note that setting the <code>CachePointer</code>
property for Output register sets is likely to be a very bad idea for this
reason, and also for performance reasons.</p>

<h3>Status Register Conventions</h3>

<ul type=disc>
 <li>Register
     [0] is a boolean that signals to a Filter XO if the row should be &#8220;filtered&#8221;,
     that is dropped, or &#8220;passed&#8221;, that is sent on to the next XO. IFF S[0] ==
     TRUE -&gt; filter.</li>
 <li>Register
     [1]: Add more definitions here&#8230;</li>
</ul>

<h2>Pros &amp; Cons</h2>

<p>Calculator setup is mid-weight, not light weight. Have to
instantiate a number of objects to represent each instruction. This is
mitigated somewhat by creating exactly one RegisterReference for each register,
and passing pointers into each Instruction instance.</p>

<h2>Threading Model</h2>

<p>Calculator is not thread safe. Each calculator object is
light weight enough that each thread can reasonably instantiate its own
Calculator.</p>

<h2>Handles</h2>

<p>A handle primitive type might be useful for managing
resources and utilizing external functions. <b>TBD</b>.</p>

<h2>Tuple Descriptors</h2>

<p>XOs will find it necessary to determine the format of the
Input and Output tuples to perform their processing. getRegisterDescriptors()
has been provided for this purpose.</p>


<hr color="#000000" noshade="noshade">

<p><font size="1">$Id$</font></p>

</body>

</html>
