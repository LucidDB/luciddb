<?xml version="1.0" encoding="UTF-8"?>
<!-- $Id$ -->
<!-- Farrago ant build script -->

<!-- These XML ENTITY "macros" help avoid redundancy in property -->
<!-- settings. They can be used with <jvmarg> or <arg> as the line -->
<!-- attribute. -->
<!DOCTYPE project [

<!ENTITY FarragoProps
"
-Dnet.sf.farrago.home=${farrago.dir}
-Djava.util.logging.config.file=${FarragoTrace.properties}
">

]>

<project name="farrago" basedir="." default="all">

  <!-- assume common parent of farrago, saffron, and fennel  -->
  <property name="open.dir" location=".."/>

  <!-- Farrago project root  -->
  <property name="farrago.dir" location="."/>

  <!-- Saffron project root -->
  <property name="saffron.dir" location="${open.dir}/saffron"/>

  <!-- import the fennel.disabled setting; this takes highest precedence -->
  <property file="initBuild.properties"/>

  <!-- import local property overrides; these take precedence over
       later definitions in this file -->
  <property file="customBuild.properties"/>

  <!-- import Saffron property overrides -->
  <property file="${saffron.dir}/customBuild.properties"/>

  <!-- Override these locations in customBuild.properties -->
  <property name="thirdparty.dir" value="${open.dir}/thirdparty"/>
  <property name="fennel.dir" location="${open.dir}/fennel"/>

  <!-- import thirdparty library settings -->
  <property file="${thirdparty.dir}/build.properties"/>

  <!-- DEPRECATED: import property settings generated by old initBuild.sh -->
  <property file="${farrago.dir}/farrago_build.properties"/>

  <!-- import environment variables as properties -->
  <property environment="env"/>


  <!-- Directories -->

  <!-- directory for non-generated source code -->
  <property name="src.dir" location="${farrago.dir}/src"/>

  <!-- directory for Farrago compiled class files (other than plugins) -->
  <property name="classes.dir" location="${farrago.dir}/classes"/>

  <!-- directory for Farrago compiled plugin .jars -->
  <property name="plugin.dir" location="${farrago.dir}/plugin"/>

  <!-- directory for Farrago compiled classes which go into plugin .jars -->
  <property name="plugin.classes.dir" location="${plugin.dir}/classes"/>

  <!-- directory for JUnit run output -->
  <property name="testlog.dir" location="${farrago.dir}/testlog"/>

  <!-- directory in which javadoc should be generated -->
  <property name="javadoc.dir" location="${farrago.dir}/doc/api"/>

  <!-- directory in which catalog data is stored -->
  <property name="catalog.dir" location="${farrago.dir}/catalog"/>

  <!-- directory for initialization scripts -->
  <property name="initsql.dir" location="${farrago.dir}/initsql"/>

  <!-- directory for unit test SQL scripts -->
  <property name="unitsql.dir" location="${farrago.dir}/unitsql"/>

  <!-- directory in which parser source code is stored -->
  <property name="parser.dir" 
    location="${src.dir}/net/sf/farrago/parser"/>

  <!-- directory in which resources are stored -->
  <property name="resource.dir" 
    location="${src.dir}/net/sf/farrago/resource"/>

  <!-- directory in which catalog data is backed up -->
  <property name="catalog.backup.dir" location="${catalog.dir}/backup"/>

  <!-- directory in which catalog sources are generated -->
  <property name="catalog.src.dir" location="${catalog.dir}/java"/>

  <!-- directory in which catalog-related XMI files are stored -->
  <property name="xmi.dir" location="${catalog.dir}/xmi"/>

  <!-- directory in which trace files are configured and generated -->
  <property name="trace.dir" location="${farrago.dir}/trace"/>

  <!-- netbeans project root -->
  <property name="netbeans.dir" location="${open.dir}/netbeans"/>

  <!-- MDR project root -->
  <property name="mdr.dir" location="${netbeans.dir}/mdr"/>

  <!-- MDRANT project root -->
  <property name="mdrant.dir" location="${mdr.dir}/extras/mdrant"/>

  <!-- ANT installation root -->
  <property name="ant.dir" location="${env.ANT_HOME}"/>

  <!-- Java installation root -->
  <property name="javahome.dir" location="${env.JAVA_HOME}"/>

  <fail unless="javacc.dir"/>
  <fail unless="junit.dir"/>
  <fail unless="macker.dir"/>
  <fail unless="jalopy.dir"/>
  <fail unless="dynamicjava.dir"/>
  <fail unless="isql.dir"/>
  <fail unless="jswat.dir"/>
  <fail unless="fennel.dir"/>
  <fail unless="sqlline.dir"/>
  <fail unless="sqlline.lib.dir"/>
  <fail unless="mdrlibs.dir"/>
  <fail unless="rmijdbc.dir"/>

  <!-- The version of ANT we require. -->
  <property name="required.ant.version" value="1.6.0"/>

  <condition property="is.correct.ant.version">
    <contains string="${ant.version}" substring="${required.ant.version}"/>
  </condition>
  <fail unless="is.correct.ant.version"
      message="Incorrect ant version '${ant.version}';
require version '${required.ant.version}'."/>

  <!-- Files -->

  <!-- XMI file containing CWM defintion  -->
  <property name="CwmMetamodel.xmi" location="${xmi.dir}/cwm-1.1.xml"/>

  <!-- XMI file contains Farrago final metamodel  -->
  <property name="FarragoMetamodel.xmi" 
    location="${xmi.dir}/FarragoMetamodel.xmi"/>

  <!-- Farrago metamodel XMI file before CWM references are resolved -->
  <property name="FarragoMetamodelUnresolved.xmi" 
    location="${xmi.dir}/FarragoMetamodelUnresolved.xmi"/>
  
  <!-- XMI file in which Farrago metamodel is generated from CWM -->
  <property name="FarragoMetamodelCWM.xmi" 
    location="${xmi.dir}/FarragoMetamodelCWM.xmi"/>

  <!-- XMI file in which Farrago metamodel combined with extension model -->
  <property name="FarragoMetamodelExt.xmi" 
    location="${xmi.dir}/FarragoMetamodelExt.xmi"/>

  <!-- XMI file containing Farrago extension metamodel -->
  <property name="FarragoExtMetamodel.xmi"
    location="${xmi.dir}/FarragoExtMetamodel.xmi"/>

  <!-- XMI file containing renumbered Farrago extension metamodel -->
  <property name="FarragoExtMetamodelTransformed.xmi"
    location="${xmi.dir}/FarragoExtMetamodelTransformed.xmi"/>

  <!-- XMI file containing UML representation of Farrago extension metamodel -->
  <property name="FarragoExtMetamodelUML.xmi"
    location="${xmi.dir}/FarragoExtMetamodelUML.xmi"/>

  <!-- Same as FarragoExtMetamodelUML, but with diagams deleted -->
  <property name="FarragoExtMetamodelUMLSansDiagrams.xmi"
    location="${xmi.dir}/FarragoExtMetamodelUMLSansDiagrams.xmi"/>

  <!-- Zipfile containing Poseidon UML XMI representation of -->
  <!-- Farrago extension metamodel -->
  <property name="FarragoExtMetamodelUML.zuml"
    location="${xmi.dir}/FarragoExtMetamodelUML.zuml"/>

  <!-- File for farrago extension model. START -->
  <!-- XMI file containing Farrago extension model -->
  <property name="ExtModel.xmi"
    location="${xmi.dir}/ExtModel.xmi"/>

  <!-- XMI file containing renumbered Farrago extension model -->
  <property name="ExtModelTransformed.xmi"
    location="${xmi.dir}/ExtModelTransformed.xmi"/>

  <!-- Extension model file name without path -->
  <basename property="ExtModelFileName" file="${ext.model.file}" suffix=".zuml"/>

  <!-- XMI file containing UML representation of Farrago extension model -->
  <property name="ExtModelUML.xmi"
    location="${xmi.dir}/${ExtModelFileName}.xmi"/>

  <!-- Same as ExtModelUML, but with diagams deleted -->
  <property name="ExtModelUMLSansDiagrams.xmi"
    location="${xmi.dir}/ExtModelUMLSansDiagrams.xmi"/>

  <!-- File for farrago extension model. END -->

  <!-- Template developer configuration file. -->
  <property name="FarragoConfTemplate.xmi"
    location="${xmi.dir}/FarragoConfTemplate.xmi"/>

  <!-- Developer configuration file generated from template. -->
  <property name="FarragoConf.xmi"
    location="${xmi.dir}/FarragoConf.xmi"/>

  <!-- file prefix for catalog storage -->
  <property name="catalog.mdrStorage"
    location="${catalog.dir}/FarragoCatalog"/>

  <property name="FarragoTrace.properties"
    location="${trace.dir}/FarragoTrace.properties"/>

  <property name="FarragoTrace.log"
    location="${trace.dir}/FarragoTrace.log"/>

  <!-- NOTE:  this has to use true/false (not 1/0) for MDR import -->
  <property name="fennel.disabled" value="false"/>

  <property name="assertions.jvmarg" value="-ea -esa"/>

  <!-- a fileset of all files for which tags should be built -->
  <fileset dir="${open.dir}" id="fileset.taggable">
    <include name="farrago/catalog/java/**/*.java"/>
    <include name="farrago/src/**/*.java"/>
    <include name="farrago/src/**/package.html"/>
    <include name="saffron/src/**/package.html"/>
    <include name="saffron/src/**/*.java"/>
    <include name="saffron/examples/**/*.java"/>
    <exclude name="**/Dummy*.java"/>
  </fileset>

  <!-- a fileset of all SQL unit tests -->
  <fileset dir="${unitsql.dir}" id="fileset.unitsql">
    <include name="**/*.sql"/>
  </fileset>
  <pathconvert property="fileset.unitsql" refid="fileset.unitsql"
    pathsep="${line.separator}" dirsep="${file.separator}" />

  <!-- a fileset of all SQL scripts to run during catalog init -->
  <filelist dir="${initsql.dir}" id="fileset.initsql"
    files=
    "createStorageWrappers.sql,createJdbcViews.sql,createSalesSchema.sql"/>
  <pathconvert property="fileset.initsql" refid="fileset.initsql"
    pathsep="${line.separator}" dirsep="${file.separator}" />

  <!-- name for a temp file used during tags generation -->
  <property name="file.taggable.tmp" 
    location="${farrago.dir}/taggedfiles"/>

  <!-- newline for use in constructing strings -->
  <property name="nl" value="${line.separator}"/>

  <!-- Classpaths -->

  <!-- third-party libraries -->
  <path id="farrago.3p.classpath">
    <pathelement location="${mdrlibs.dir}/mdrant.jar"/>
    <pathelement location="${mdrlibs.dir}/nbmdr.jar"/>
    <pathelement location="${mdrlibs.dir}/mdrapi.jar"/>
    <pathelement location="${mdrlibs.dir}/jmiutils.jar"/>
    <pathelement location="${mdrlibs.dir}/mof.jar"/>
    <pathelement location="${mdrlibs.dir}/jmi.jar"/>
    <pathelement location="${mdrlibs.dir}/openide-util.jar"/>
    <!-- TODO jvs 12-Feb-2004:  get rid of openide-lookup.jar in a while -->
    <pathelement location="${mdrlibs.dir}/openide-lookup.jar"/>
    <pathelement location="${thirdparty.dir}/mondrian-resource.jar"/>
    <pathelement location="${thirdparty.dir}/mondrian-xom.jar"/>
    <pathelement location="${mdrlibs.dir}/mdrjdbc.jar"/>
    <pathelement location="${junit.dir}/junit.jar"/>
    <pathelement location="${saffron.dir}/classes"/>
    <pathelement location="${ant.dir}/lib/xml-apis.jar"/>
    <pathelement location="${ant.dir}/lib/xercesImpl.jar"/>
    <pathelement location="${javahome.dir}/lib/tools.jar"/>
    <pathelement location="${rmijdbc.dir}/dist/lib/RmiJdbc.jar"/>
  </path>
  <property name="farrago.3p.classpath" refid="farrago.3p.classpath"/>

  <!-- classpath for main build (after catalog codegen) -->
  <path id="farrago.build.classpath">
    <pathelement path="${farrago.3p.classpath}"/>
    <pathelement location="${catalog.src.dir}"/>
    <pathelement location="${sqlline.lib.dir}/sqlline.jar"/>
    <pathelement location="${sqlline.lib.dir}/jline.jar"/>
    <pathelement location="${dynamicjava.dir}/lib/dynamicjava.jar"/>
  </path>
  <property name="farrago.build.classpath" refid="farrago.build.classpath"/>

  <!-- classpath for plugin build) -->
  <path id="plugin.build.classpath">
    <pathelement path="${farrago.build.classpath}"/>
    <pathelement location="${classes.dir}"/>
  </path>
  <property name="plugin.build.classpath" refid="plugin.build.classpath"/>

  <!-- classpath for execution.  It's very important for classes.dir
       to come BEFORE catalog.src.dir so that MDR will make our Impl
       classes override their generated counterparts.  The reason
       src.dir is here is so that resource .xml files can be found at
       runtime without copying.  -->
  <path id="farrago.run.classpath">
    <pathelement path="${farrago.3p.classpath}"/>
    <pathelement location="${classes.dir}"/>
    <pathelement location="${catalog.src.dir}"/>
    <pathelement location="${src.dir}"/>
    <pathelement location="${dynamicjava.dir}/lib/dynamicjava.jar"/>
    <pathelement location="${saffron.dir}/lib/hsqldb.jar"/>
  </path>
  <property name="farrago.run.classpath" refid="farrago.run.classpath"/>

  <!-- sourcepath for debugging -->
  <path id="farrago.sourcepath">
    <pathelement location="${dynamicjava.dir}/djava/sources"/>
    <pathelement location="${saffron.dir}/src"/>
    <pathelement location="${saffron.dir}/examples"/>
    <pathelement location="${catalog.src.dir}"/>
    <pathelement location="${src.dir}"/>
  </path>
  <property name="farrago.sourcepath" refid="farrago.sourcepath"/>


  <!-- classpath for running from sqlline -->
  <path id="sqlline.classpath">
    <pathelement location="${sqlline.lib.dir}/sqlline.jar"/>
    <pathelement location="${sqlline.lib.dir}/jline.jar"/>
    <pathelement path="${farrago.run.classpath}"/>
  </path>
  <property name="sqlline.classpath" refid="sqlline.classpath"/>

  <!-- classpath for reentrantly invoking ant -->
  <path id="ant.classpath">
    <pathelement location="${ant.dir}/lib/ant.jar"/>
    <pathelement location="${ant.dir}/lib/ant-launcher.jar"/>
    <pathelement location="${ant.dir}/lib/junit.jar"/>
    <pathelement location="${ant.dir}/lib/xercesImpl.jar"/>
    <pathelement location="${ant.dir}/lib/xml-apis.jar"/>
  </path>
  <property name="ant.classpath" refid="ant.classpath"/>

  <!-- classpath for reentrantly invoking ant from createUserRepository -->
  <path id="createUserRepository.classpath">
    <pathelement path="${farrago.run.classpath}"/>
    <pathelement path="${ant.classpath}"/>
  </path>
  <property name="createUserRepository.classpath" 
    refid="createUserRepository.classpath"/>

  <!-- sourcepath for debugging iSQL -->
  <path id="jswat.isql.sourcepath">
    <pathelement location="${isql.dir}/src"/>
    <pathelement path="${farrago.sourcepath}"/>
  </path>
  <property name="jswat.isql.sourcepath" refid="jswat.isql.sourcepath"/>

  <!-- sourcepath for debugging sqlline -->
  <path id="jswat.sqlline.sourcepath">
    <pathelement location="${sqlline.dir}/src"/>
    <pathelement path="${farrago.sourcepath}"/>
  </path>
  <property name="jswat.sqlline.sourcepath" refid="jswat.sqlline.sourcepath"/>

  <!-- sourcepath for debugging via JUnit -->
  <path id="jswat.junit.sourcepath">
    <pathelement location="${junit.dir}/src.jar"/>
    <pathelement path="${jswat.sqlline.sourcepath}"/>
  </path>
  <property name="jswat.junit.sourcepath" refid="jswat.junit.sourcepath"/>

  <!-- sourcepath for debugging MDR -->
  <path id="mdr.sourcepath">
    <pathelement location="${open.dir}/netbeans/mdr/src"/>
    <pathelement path="${farrago.sourcepath}"/>
  </path>
  <property name="mdr.sourcepath" refid="mdr.sourcepath"/>

  <!-- sourcepath for debugging server -->
  <path id="server.sourcepath">
    <pathelement location="${rmijdbc.dir}/src"/>
    <pathelement path="${farrago.sourcepath}"/>
  </path>
  <property name="farrago.sourcepath" refid="farrago.sourcepath"/>


  <!-- Macro Definitions -->
  <import file="buildMacros.xml"/>

  <!-- classpath for running from iSQL -->
  <path id="isql.run.classpath">
    <pathelement path="${isql.classpath}"/>
    <pathelement path="${farrago.run.classpath}"/>
  </path>
  <property name="isql.run.classpath" refid="isql.run.classpath"/>

  <!-- Targets -->

  <!-- 

  Declare mdr task used for catalog manipulation.  Note that in order
  to use this task, we always fork an ant subprocess using java (not
  ant or antcall).  There are two reasons for this.  Most importantly,
  it makes sure that the repository is shut down properly.  Without
  this, invocations of mdr sometimes interfere with our own java tasks
  (e.g. populateCatalog).  Another reason is that it gives us a chance
  to set Java properties, most importantly the one that controls the
  mdr logging level, so we can suppress some spurious exception
  reports.

  -->

  <target name="mdr_taskdef">
    <taskdef name="mdr" classname="org.netbeans.mdrant.MdrTask"
      classpathref="farrago.run.classpath"/>
  </target>

  <!-- default target:  assumes catalog has already been created -->
  <target name="all" 
    depends="compile, buildJdbcPlugin"/>

  <target name="compile" depends="generateResources,ddlParser">
    <javaCompile
      srcdir="${src.dir}"
      destdir="${classes.dir}"
      classpathref="farrago.build.classpath">
      <include name="**/*.java" />
      <exclude name="**/namespace/jdbc/**/*.java" />
    </javaCompile>
  </target>

  <target name="buildJdbcPlugin" 
    depends="checkJdbcPluginUptodate" unless="plugin.jdbc.uptodate">
    <javaCompile
      srcdir="${src.dir}"
      destdir="${plugin.classes.dir}"
      classpathref="plugin.build.classpath">
      <include name="**/namespace/jdbc/**/*.java" />
    </javaCompile>
    <jar jarfile="${plugin.dir}/FarragoMedJdbc.jar">
      <fileset dir="${plugin.classes.dir}">
        <include name="**/namespace/jdbc/**/*.class" />
      </fileset>
      <manifest>
        <attribute 
          name="DataWrapperClassName" 
          value="net.sf.farrago.namespace.jdbc.MedJdbcForeignDataWrapper" />
      </manifest>
    </jar>
  </target>

  <target name="checkJdbcPluginUptodate">
    <uptodate property="plugin.jdbc.uptodate" 
      targetfile="${plugin.dir}/FarragoMedJdbc.jar">
      <srcfiles dir="${src.dir}" 
        includes="**/namespace/jdbc/**/*.java"/>
    </uptodate>
  </target>

  <!-- cleans for non-generated code only; does not touch catalog -->
  <!-- TODO:  get rid of saffron and DdlParser entries in a little while -->
  <target name="clean" depends="cleanTestLogs">
    <delete includeEmptyDirs="true" quiet="true">
      <fileset dir="${classes.dir}" includes="**/*.class"/>
      <fileset dir="${plugin.classes.dir}" includes="**/*.class"/>
      <fileset dir="${plugin.dir}" includes="**/*.jar"/>
      <fileset dir="${classes.dir}"
        includes="net/sf/saffron/runtime/**"/>
      <fileset dir="${classes.dir}"
        includes="saffron/runtime/**"/>
      <fileset dir="${classes.dir}"
        includes="net/sf/farrago/dynamic/**"/>
      <fileset dir="${farrago.dir}" includes="junit*.properties"/>
      <fileset dir="${farrago.dir}" includes="hs_err_pid*.log"/>
      <fileset dir="${src.dir}/net/sf/farrago/resource">
        <include name="*.java"/>
        <include name="FarragoResource_en_US.properties"/>
        <include name="FarragoResource.properties"/>
      </fileset>
      <fileset dir="${src.dir}/net/sf/farrago/parser">
        <include name="CombinedParser.jj"/>
        <include name="DdlParser.java"/>
        <include name="DdlParserConstants.java"/>
        <include name="DdlParserTokenManager.java"/>
        <include name="FarragoParserImpl.java"/>
        <include name="FarragoParserImplConstants.java"/>
        <include name="FarragoParserImplTokenManager.java"/>
        <include name="TokenMgrError.java"/>
        <include name="ParseException.java"/>
        <include name="JavaCharStream.java"/>
        <include name="Token.java"/>
        <include name="ASCII_UCodeESC_CharStream.java"/>
      </fileset>
    </delete>
  </target>

  <target name="cleanTestLogs">
    <delete includeEmptyDirs="true" quiet="true">
      <fileset dir="${testlog.dir}" includes="*.txt"/>
      <fileset dir="${testlog.dir}" includes="*.log"/>
      <fileset dir="${testlog.dir}" includes="*.dif"/>
      <fileset dir="${unitsql.dir}" includes="**/*.log"/>
    </delete>
  </target>

  <!-- creates catalog and populates with initial metadata -->
  <target name="createCatalog">
    <mkdir dir="${classes.dir}"/>
    <mkdir dir="${plugin.dir}"/>
    <mkdir dir="${plugin.classes.dir}"/>
    <antcall target="createClasspathFile"/>
    <antcall target="compileCatalog"/>
    <antcall target="createMdrTestData"/>
    <antcall target="importConfig"/>
    <antcall target="backupCatalog"/>
    <antcall target="populateTestData"/>
    <!-- NOTE:  redundant backup is an intentional checkpoint; in case
    populateTestData fails, it can be debugged from restored empty catalog -->
    <antcall target="backupCatalog"/>
  </target>

  <target name="compileCatalog" 
    depends="cleanCatalog,createRepository"/>

  <!-- initialize catalog repository -->
  <target name="createRepository" depends="configureTrace,convertExtMetamodel, convertExtModel">
    <mkdir dir="${catalog.dir}"/>
    <mkdir dir="${catalog.src.dir}"/>
    <antcall target="transformMetamodel"/>
    <antFork target="forked_importMetamodel"/>
    <javaCompile
      srcdir="${catalog.src.dir}"
      destdir="${catalog.src.dir}"
      classpathref="farrago.3p.classpath">
      <include name="**/*.java"/>
    </javaCompile>
    <antcall target="backupCatalog"/>
    <antFork target="forked_createTempCatalogRepository"/>
    <antcall target="generateMetadataFactory"/>
    <antcall target="restoreCatalog"/>
    <antcall target="all"/>
    <antFork target="forked_createCatalogRepository"/>
  </target>

  <!-- NOTE:  don't use mapClass below to make sure all generated
  .java files can actually be compiled -->

  <target name="forked_importMetamodel" depends="mdr_taskdef">
    <mdr storageFile="${catalog.mdrStorage}">
      <instantiate name="FarragoMetamodel"/>
      <readXMI 
        file="${FarragoMetamodel.xmi}"
        extent="FarragoMetamodel"/>
      <mapJava
        dir="${catalog.src.dir}" 
        extent="FarragoMetamodel"/>
    </mdr>
  </target>

  <target name="forked_createCatalogRepository" depends="mdr_taskdef">
    <mdr storageFile="${catalog.mdrStorage}">
      <instantiate 
        name="FarragoCatalog"
        extent="FarragoMetamodel"
        package="Farrago"/>
      <writeDTD
        file="${xmi.dir}/FarragoCatalog.dtd"
        extent="FarragoCatalog"/>
    </mdr>
  </target>

  <target name="forked_createTempCatalogRepository" depends="mdr_taskdef">
    <mdr storageFile="${catalog.mdrStorage}">
      <instantiate 
        name="FarragoTempCatalog"
        extent="FarragoMetamodel"
        package="Farrago"/>
    </mdr>
  </target>

  <!-- combine transformed CWM with FarragoExt to create final XMI for
  Farrago metamodel -->
  <target name="transformMetamodel">
	 <xslt style="${xmi.dir}/transformFEM.xsl"
		in="${FarragoExtMetamodel.xmi}"
		out="${FarragoExtMetamodelTransformed.xmi}" />
	 <replace file="${FarragoExtMetamodelTransformed.xmi}"
		token="org.omg.xmi.namespace.Model" value="omg.org/mof.Model/1.3" />
    <antcall target="transformExtModel"/>
    <xslt style="${xmi.dir}/transformCWM.xsl"
      in="${CwmMetamodel.xmi}"
      out="${FarragoMetamodelUnresolved.xmi}">
      <param name="femXmiFilename" 
        expression="${FarragoExtMetamodelTransformed.xmi}"/>
      <param name="extXmiFilename"
        expression="${ExtModelTransformed.xmi}"/>
    </xslt>
    <xslt style="${xmi.dir}/resolveCwmRefs.xsl"
      in="${FarragoMetamodelUnresolved.xmi}"
      out="${FarragoMetamodel.xmi}"/>
  </target>
  
  <target name="transformExtModel"  if="ext.model.file">
	 <xslt style="${xmi.dir}/transformFEME.xsl"
		in="${ExtModel.xmi}"
		out="${ExtModelTransformed.xmi}" >
     <param name="modelPrefix" 
        expression="${ext.model.prefix}"/>
     </xslt>
	 <replace file="${ExtModelTransformed.xmi}"
		token="org.omg.xmi.namespace.Model" value="omg.org/mof.Model/1.3" />
  </target>    

  <target name="combineExtModel"  if="ext.model.file">
	 <xslt style="${xmi.dir}/combineExtModel.xsl"
		in="${FarragoMetamodelCWM.xmi}"
		out="${FarragoMetamodelExt.xmi}">
      <param name="extXmiFilename" 
        expression="${ExtModelTransformed.xmi}"/>
      <param name="pkgName" 
        expression="${ext.package.name}"/>
      <param name="pkgPrefix" 
        expression="${ext.package.prefix}"/>
     </xslt>
     <copy file="${FarragoMetamodelExt.xmi}" tofile="${FarragoMetamodelCWM.xmi}" overwrite="yes"/>
  </target>    

  <!-- generate developer configuration file and import it -->
  <target name="importConfig">
    <copy file="${FarragoConfTemplate.xmi}"
      tofile="${FarragoConf.xmi}" overwrite="true"/>
    <replace file="${FarragoConf.xmi}">
      <replacefilter token="@fennel.disabled@" value="${fennel.disabled}"/>
      <replacefilter token="@databaseDir@" value="${catalog.dir}"/>
      <replacefilter token="@resourceDir@" value="${fennel.dir}/common"/>
    </replace>
    <antFork target="forked_importConfig"/>
  </target>

  <!-- set up the default trace configuration file -->
  <target name="configureTrace">
    <mkdir dir="${trace.dir}"/>
    <touch file="${FarragoTrace.properties}"/>
    <propertyfile file="${FarragoTrace.properties}"
      comment="Farrago developer tracing configuration (do not add comments)">
      <entry key="handlers" default="java.util.logging.FileHandler"/>
      <entry key="java.util.logging.FileHandler.formatter" 
        default="java.util.logging.SimpleFormatter"/>
      <entry key=".level" default="CONFIG"/>
      <entry key="java.util.logging.FileHandler.pattern" 
        default="${FarragoTrace.log}"/>
      <entry key="java.util.logging.FileHandler.append" default="true"/>
    </propertyfile>
  </target>

  <target name="forked_importConfig" depends="mdr_taskdef">
    <mdr storageFile="${catalog.mdrStorage}">
      <readXMI
        file="${FarragoConf.xmi}"
        extent="FarragoCatalog"/>
    </mdr>
  </target>

  <!-- write initial metadata to catalog -->
  <target name="populateCatalog">
    <javaExec classpathref="farrago.run.classpath"
      classname="net.sf.farrago.db.FarragoDatabase"/>
  </target>

  <!-- write sample schema to catalog -->
  <target name="populateTestData" depends="populateCatalog,populateTestSchema"/>

  <target name="populateTestSchema">
    <junit printsummary="yes" fork="yes" haltonerror="yes" haltonfailure="yes"
      tempdir="${testlog.dir}">
      <classpath refid="sqlline.classpath"/>
      <jvmarg line="${assertions.jvmarg}"/>
      <jvmarg line="&FarragoProps;"/>
      <sysproperty key="java.ext.dirs" value="${sqlline.dir}"/>
      <sysproperty key="net.sf.farrago.fileset.unitsql" 
        value="${fileset.initsql}"/>
      <sysproperty key="net.sf.farrago.test.diff" value="true"/>
      <formatter type="plain"/>
      <formatter type="xml"/> <!-- for integration builds -->
      <test todir="${testlog.dir}" name="net.sf.farrago.test.FarragoSqlTest" />
    </junit>
  </target>

  <!-- back up the current catalog contents -->
  <target name="backupCatalog">
    <delete includeEmptyDirs="true" quiet="true">
      <fileset dir="${catalog.backup.dir}" includes="*"/>
    </delete>
    <mkdir dir="${catalog.backup.dir}"/>
    <copy todir="${catalog.backup.dir}">
      <fileset dir="${catalog.dir}" includes="FarragoCatalog.bt?"/>
      <fileset dir="${catalog.dir}" includes="db.dat"/>
    </copy>
  </target>

  <!-- restore catalog from backup -->
  <target name="restoreCatalog" depends="cleanCatalogData">
    <copy todir="${catalog.dir}">
      <fileset dir="${catalog.backup.dir}"/>
    </copy>
  </target>

  <!-- NOTE:  doesn't work yet -->
  <target name="importCatalog" depends="mdr_taskdef">
    <mdr storageFile="${catalog.mdrStorage}">
      <readXMI 
        file="${xmi.dir}/FarragoCatalogInit.xml"
        extent="FarragoCatalog"/>
    </mdr>
  </target>

  <!-- delete the catalog and everything generated for it -->
  <target name="cleanCatalog" depends="clean,cleanCatalogData">
    <delete file="${FarragoExtMetamodel.xmi}"/>
    <delete file="${FarragoExtMetamodelUML.xmi}"/>
    <delete file="${FarragoExtMetamodelUMLSansDiagrams.xmi}"/>
    <delete file="${FarragoExtMetamodelTransformed.xmi}"/>
    <delete file="${FarragoMetamodel.xmi}"/>
    <delete file="${FarragoMetamodelUnresolved.xmi}"/>
    <delete file="${xmi.dir}/FarragoCatalog.dtd"/>
    <delete file="${ExtModel.xmi}"/>
    <delete file="${ExtModelTransformed.xmi}"/>
    <delete file="${ExtModelUML.xmi}"/>
	<delete file="${ExtModelUMLSansDiagrams.xmi}"/>
	<delete file="${xmi.dir}/UnResolvedExtModel.xmi" />
  	<delete file="${FarragoMetamodelCWM.xmi}" />
  	<delete file="${FarragoMetamodelExt.xmi}" />
    <delete 
      file="${src.dir}/net/sf/farrago/FarragoMetadataFactory.java"/>
    <delete dir="${catalog.src.dir}"/>
  </target>

  <!-- delete catalog data only -->
  <target name="cleanCatalogData">
    <delete>
      <fileset dir="${catalog.dir}" includes="*.dat"/>
      <fileset dir="${catalog.dir}" includes="FarragoCatalog.bt?"/>
    </delete>
  </target>    

  <target name="exportCatalog" depends="mdr_taskdef">
    <mdr storageFile="${catalog.mdrStorage}">
      <writeXMI 
        file="${xmi.dir}/FarragoCatalogExport.xmi" 
        extent="FarragoCatalog"
        xmiVersion = "1.2"/>
    </mdr>
  </target>    

  <target name="exportMetamodel" depends="mdr_taskdef">
    <mdr storageFile="${catalog.mdrStorage}">
      <writeXMI 
        file="${xmi.dir}/FarragoMetamodelExport.xmi" 
        extent="FarragoMetamodel"
        xmiVersion = "1.2"/>
    </mdr>
  </target>    

  <target name="unzipExtMetamodel">
    <unzip src="${FarragoExtMetamodelUML.zuml}" dest="${xmi.dir}">
      <patternset>
        <include name="FarragoExtMetamodelUML.xmi"/>
      </patternset>
    </unzip>
  </target>

  <!-- unzip farrago extension model -->
  <target name="unzipExtModel" if="ext.model.file">
    <unzip src="${ext.model.file}" dest="${xmi.dir}">
      <patternset>
        <include name="${ExtModelFileName}.xmi"/>
      </patternset>
    </unzip>
  </target>

  <!-- NOTE:  Logger setting squelches unwanted INFORMATIONAL messages -->
  <target name="convertExtMetamodel" depends="unzipExtMetamodel">
    <uml2mof umlmodelname="${FarragoExtMetamodelUML.xmi}"
	  outputfilename="${FarragoExtMetamodel.xmi}"
	  umlsansdiagrams="${FarragoExtMetamodelUMLSansDiagrams.xmi}"/>
  </target>

  <target name="convertExtModel" depends="unzipExtModel"  if="ext.model.file">
    <uml2mof umlmodelname="${ExtModelUML.xmi}"
	  outputfilename="${ExtModel.xmi}"
	  umlsansdiagrams="${ExtModelUMLSansDiagrams.xmi}"/>
  </target>

  <target name="delPrim">
	 <xslt style="${xmi.dir}/delPrim.xsl"
		in="${ExtModel.xmi}"
		out="${xmi.dir}/UnResolvedExtModel.xmi" />
  </target>

  <target name="checkResourceUptodate">
    <uptodate property="resource.uptodate" 
      srcfile="${resource.dir}/FarragoResource.xml"
      targetfile="${resource.dir}/FarragoResource.java"/>
  </target>

  <target name="generateResources" depends="checkResourceUptodate"
    unless="resource.uptodate">
    <!-- FarragoException.class needs to exist for reflection -->
    <javaCompile
      srcdir="${src.dir}"
      destdir="${classes.dir}"
      classpathref="farrago.3p.classpath">
      <include name="**/FarragoException.java" />
    </javaCompile>
    <taskdef name="resgen" classname="mondrian.resource.ResourceGenTask">
      <classpath refid="farrago.run.classpath"/>
    </taskdef>
    <resgen srcdir="${src.dir}" locales="en_US">
      <include name="net/sf/farrago/resource/FarragoResource.xml"/>
    </resgen>
  </target>

  <target name="checkParserUptodate">
    <uptodate property="parser.uptodate" 
      targetfile="${parser.dir}/FarragoParserImpl.java">
      <srcfiles dir="${parser.dir}" includes="DdlParser.jj"/>
      <srcfiles dir="${parser.dir}" includes="CommonDdlParser.jj"/>
      <srcfiles dir="${saffron.dir}" 
        includes="src/net/sf/saffron/sql/parser/CommonParser.jj"/>
    </uptodate>
  </target>

  <!-- Generate the DDL parser. Generated files are:
       TokenMgrError.java, ParseException.java,
       JavaCharStream.java, Token.java, ASCII_UCodeESC_CharStream.java --> 
  <target name="ddlParser" depends="checkParserUptodate"
    unless="parser.uptodate">
    <delete file="${parser.dir}/CombinedParser.jj" quiet="true"/>
    <concat 
      destfile="${parser.dir}/CombinedParser.jj"
      append="false">
      <fileset dir="${parser.dir}" includes="DdlParser.jj"/>
      <fileset dir="${parser.dir}" includes="CommonDdlParser.jj"/>
      <fileset dir="${saffron.dir}" 
        includes="src/net/sf/saffron/sql/parser/CommonParser.jj"/>
    </concat>
    <chmod file="${parser.dir}/CombinedParser.jj" perm="a-w"/>
    <javacc 
      target="${parser.dir}/CombinedParser.jj" 
      javacchome="${javacc.dir}"/>
  </target>

  <!-- run all JUnit test cases (or a single test case chosen with -->
  <!-- property junit.class, normally from script junitSingle -->
  <target name="junit" depends="all,cleanTestLogs">
    <delete file="${FarragoTrace.log}"/>
    <mkdir dir="${testlog.dir}"/>
    <junit printsummary="yes" fork="yes" failureproperty="junit.failure"
      tempdir="${testlog.dir}">
      <classpath refid="sqlline.classpath"/>
      <jvmarg line="${assertions.jvmarg}"/>
      <jvmarg line="&FarragoProps;"/>
      <sysproperty key="java.ext.dirs" value="${sqlline.dir}"/>
      <sysproperty key="net.sf.farrago.fileset.unitsql" 
        value="${fileset.unitsql}"/>
      <formatter type="plain"/>
      <formatter type="xml"/> <!-- for integration builds -->
      <batchtest todir="${testlog.dir}" unless="junit.class">
        <fileset dir="${classes.dir}">
          <include name="**/*Test.class"/>
        </fileset>
      </batchtest>
      <test todir="${testlog.dir}" if="junit.class"
        name="${junit.class}" />
    </junit>
    <delete file="${FarragoTrace.log}.lck"/>
    <fail message="Test failure(s)" if="junit.failure"/>
  </target>

  <target name="test">
    <antcall target="createCatalog"/>
    <antcall target="junit"/>
  </target>

  <!-- create the mdrlibs distribution; -->
  <!-- only use after building netbeans -->
  <target name="distLib3p">
    <mkdir dir="${mdrlibs.dir}"/>
    <copy 
      file="${mdrant.dir}/release/mdrant.jar" 
      todir="${mdrlibs.dir}"/>
    <copy 
      file="${mdr.dir}/external/mof.jar"
      todir="${mdrlibs.dir}"/>
    <copy 
      file="${mdr.dir}/external/jmi.jar"
      todir="${mdrlibs.dir}"/>
    <copy 
      file="${mdr.dir}/netbeans/modules/autoload/mdrapi.jar"
      todir="${mdrlibs.dir}"/>
    <copy 
      file="${mdr.dir}/netbeans/modules/ext/nbmdr.jar"
      todir="${mdrlibs.dir}"/>
    <copy 
      file="${mdr.dir}/extras/jdbcstorage/release/mdrjdbc.jar"
      todir="${mdrlibs.dir}"/>
    <copy 
      file="${mdr.dir}/netbeans/modules/autoload/ext/jmiutils.jar"
      todir="${mdrlibs.dir}"/>
    <copy 
      file="${mdr.dir}/extras/uml2mof/release/uml2mof.jar"
      todir="${mdrlibs.dir}"/>
    <copy 
      file="${mdr.dir}/extras/uml2mof/release/uml-1.4.jar"
      todir="${mdrlibs.dir}"/>
    <copy 
      file="${netbeans.dir}/openide/util/netbeans/lib/openide-util.jar"
      todir="${mdrlibs.dir}"/>
    <copy
      file="${farrago.dir}/lib3p/LICENSE.src"
      tofile="${mdrlibs.dir}/LICENSE"/>
  </target>

  <!-- debug a JUnit test case; called from script junitDebug -->
  <target name="jswat.junit" depends="all">
    <fail message="property junit.class not defined" unless="junit.class"/>
    <jswatDebug 
      classpath="${sqlline.classpath}"
      sourcepath="${jswat.junit.sourcepath}"
      classname="junit.textui.TestRunner">
      <jvmargs>
        <arg value="-Dnet.sf.farrago.fileset.unitsql=${fileset.unitsql}"/>
        <arg value="-Djava.ext.dirs=${sqlline.dir}"/>
      </jvmargs>
      <programargs>
        <arg value="${junit.class}"/>
      </programargs>
    </jswatDebug>
  </target>

  <!-- Generate the Fennel C++ proxy classes for FEM -->
  <target name="generateFemCpp" depends="compile">
    <ant antfile="p4fem.xml"/>
    <javah
      classpathref="farrago.run.classpath"
      class="net.sf.farrago.fennel.FennelStorage"
      outputFile="${open.dir}/fennel/farrago/NativeMethods.h"/>
    <javaExec
      classname="net.sf.farrago.catalog.codegen.ProxyGen"
      classpathref="farrago.run.classpath">
      <arg value="${fennel.dir}/farrago/FemGeneratedClasses.h"/>
      <arg value="${fennel.dir}/farrago/FemGeneratedMethods.h"/>
      <arg value="FEM.Fennel"/>
      <arg value="Fem"/>
    </javaExec>
  </target>

  <!-- Generate FarragoMetadataFactory -->
  <target name="generateMetadataFactory">
    <!-- FactoryGen.class needed for code generation -->
    <javaCompile
      srcdir="${src.dir}"
      destdir="${classes.dir}"
      classpathref="farrago.build.classpath">
      <include name="**/FactoryGen.java" />
    </javaCompile>
    <javaExec
      classname="net.sf.farrago.catalog.codegen.FactoryGen"
      classpathref="farrago.run.classpath">
      <arg 
        value="${src.dir}/net/sf/farrago/FarragoMetadataFactory.java"/>
      <arg value="net.sf.farrago"/>
      <arg value="FarragoMetadataFactory"/>
      <arg value="net.sf.farrago.FarragoPackage"/>
      <arg value="FarragoTempCatalog"/>
    </javaExec>
  </target>


  <!-- Debugging target for listing repository extents -->
  <target name="printRepositoryExtents" depends="mdr_taskdef">
    <mdr storageFile="${catalog.mdrStorage}">
      <printExtentNames/>
    </mdr>
  </target>

  <!-- Utility target for dumping the value of fileset.taggable into
  file.taggable.tmp in a form suitable for consumption by ctags,
  which always expects a Unix file format -->
  <target name="tags.find_taggable_files">
    <concat destfile="${file.taggable.tmp}">replaceme</concat>
    <pathconvert property="files.taggable" 
      pathsep="${line.separator}"
      dirsep="/" refid="fileset.taggable" >
      <map from="${farrago.dir}" to="." />
    </pathconvert>
    <replace file="${file.taggable.tmp}" 
      token="replaceme" value="${files.taggable}" />
    <fixcrlf srcDir="${farrago.dir}" includes="taggedfiles"
      eol="lf" eof="remove" />
  </target>

  <target name="macker">
    <path id="macker.classpath">
      <fileset dir="${macker.dir}/lib" includes="*.jar"/>
      <fileset dir="${macker.dir}/build" includes="macker.jar"/>
    </path>
    <taskdef name="macker"
      classname="net.innig.macker.ant.MackerAntTask"
      classpathref="macker.classpath"/>

    <macker maxMessages="10">
      <rules dir="${src.dir}" includes="**/*macker*.xml" />
      <classes dir="${classes.dir}">
        <include name="**/*.class" />
      </classes>
    </macker>
  </target>

  <!-- Beautify Farrago source code.  This forks a separate ant process using
       the server JVM to work around a problem documented at
       http://jalopy.sourceforge.net/javadoc.html. -->
  <target name="jalopy" depends="compile"
    description="Runs jalopy on all source code.">
      <antFork value="forked_jalopy">
        <jvmargs>
          <jvmarg value="-server"/>
        </jvmargs>
      </antFork>
  </target>

  <target name="forked_jalopy">
    <taskdef name="jalopy" 
      classname="de.hunsicker.jalopy.plugin.ant.AntPlugin">
      <classpath>
        <fileset dir="${jalopy.dir}/lib">
          <include name="*.jar"/>
        </fileset>
      </classpath>
    </taskdef>
    <!-- NOTE: may want to turn force off once rules stabilize -->
    <jalopy backup="true" convention="${src.dir}/jalopy.xml"
      classpathref="farrago.run.classpath" history="FILE" force="true">
      <fileset dir="${src.dir}">
        <include name="**/*.java"/>
        <!-- TODO:  single-source the following set of generated files -->
        <exclude name="net/sf/farrago/parser/FarragoParserImpl.java"/>
        <exclude name="net/sf/farrago/parser/FarragoParserImplConstants.java"/>
        <exclude 
          name="net/sf/farrago/parser/FarragoParserImplTokenManager.java"/>
        <exclude name="net/sf/farrago/parser/TokenMgrError.java"/>
        <exclude name="net/sf/farrago/parser/ParseException.java"/>
        <exclude name="net/sf/farrago/parser/JavaCharStream.java"/>
        <exclude name="net/sf/farrago/parser/Token.java"/>
        <exclude name="net/sf/farrago/parser/ASCII_UCodeESC_CharStream.java"/>
        <exclude name="net/sf/farrago/resource/FarragoResource*.java"/>
      </fileset>
    </jalopy>
  </target>

  <!-- generate Emacs tags -->
  <target name="etags">
    <antcall target="tags.find_taggable_files"/>
    <exec dir="${farrago.dir}" executable="ctags">
      <arg line="-e"/>
      <arg line="-L taggedfiles"/>
    </exec>
    <delete file="${file.taggable.tmp}" quiet="true"/>
  </target>

  <!-- generate Farrago javadoc (clean first to get rid of dummy classes) -->
  <target name="javadoc" depends="clean, compile">
    <delete includeEmptyDirs="true" quiet="true">
      <fileset dir="${javadoc.dir}" includes="*"/>
    </delete>
    <mkdir dir="${javadoc.dir}"/>
    <javadoc
      private="true"
      destdir="${javadoc.dir}"
      source="1.4"
      classpathref="farrago.run.classpath">
      <packageset dir="${catalog.src.dir}">
        <include name="**"/>
      </packageset>
      <packageset dir="${src.dir}">
        <include name="**"/>
      </packageset>
      <packageset dir="${saffron.dir}/src">
        <include name="**"/>
        <exclude name="net/sf/saffron/walden/**"/>
        <exclude name="net/sf/saffron/web/**"/>
      </packageset>
      <packageset dir="${saffron.dir}/examples">
        <include name="**"/>
      </packageset>
      <link href="http://www.netbeans.org/download/dev/javadoc/MdrAPIs"/>
      <link href="http://java.sun.com/products/jmi/jmi-1_0-fr-doc"/>
	  <link href="http://java.sun.com/j2se/1.4.2/docs/api"/>
	  <link href="http://java.sun.com/j2ee/1.4/docs/api"/>
      <link href="http://www.junit.org/junit/javadoc/3.8.1"/>
      <tag name="pre" description="Pre-condition:"
           scope="constructors,methods"/>
      <tag name="post" description="Post-condition:"
           scope="constructors,methods"/>
    </javadoc>
  </target>

  <!-- create the documentation tarball -->
  <target name="buildDoc" depends="javadoc">
    <delete file="${farrago.dir}/doc.tar" />
    <delete file="${farrago.dir}/doc.tar.gz" />
    <tar tarfile="${farrago.dir}/doc.tar">
      <tarfileset dir="${farrago.dir}" includes="doc/**" excludes="**/*.vsd"/>
    </tar>
    <gzip zipfile="${farrago.dir}/doc.tar.gz"   
              src="${farrago.dir}/doc.tar" />
    <delete file="${farrago.dir}/doc.tar" />
  </target>

  <!-- run iSQL -->
  <target name="isql" depends="all">
    <iSQL
      classpath="isql.run.classpath"
      propertieshome="${farrago.dir}/isql">
    </iSQL>
  </target>

  <!-- NOTE:  To debug iSQL itself, you have to get its source and
  compile a debug build.
  -->

  <!-- run JSwat on iSQL -->
  <target name="jswat.isql" depends="all">
    <jswatDebug
      classpath="${isql.run.classpath}"
      sourcepath="${jswat.isql.sourcepath}"
      classname="org.isqlviewer.core.Launcher">
      <jvmargs>
        <arg value="-Disql.home=${farrago.dir}/isql"/>
      </jvmargs>
    </jswatDebug>
  </target>

  <!-- run JSwat on sqlline in interactive mode -->
  <target name="jswat.sqlline" depends="all">
    <jswatDebug
      classpath="${sqlline.classpath}"
      sourcepath="${jswat.sqlline.sourcepath}"
      classname="sqlline.SqlLine">
      <jvmargs>
        <arg value="-Djava.ext.dirs=${sqlline.dir}"/>
       <jvmarg line="&FarragoProps;"/>
      </jvmargs>
      <programargs>
        <arg value="-u jdbc:farrago: -d net.sf.farrago.jdbc.engine.FarragoJdbcEngineDriver -n guest"/>
      </programargs>
    </jswatDebug>
  </target>

  <!-- Dump the file classpath.gen for use outside of ant -->
  <target name="createClasspathFile">
    <delete file="${file.classpath}" quiet="true"/>
    <concat destfile="${file.classpath}">cccp</concat>
    <replace file="${file.classpath}" token="cccp"
      value="${sqlline.classpath}"/>
  </target>
  <property name="file.classpath"
    location="${farrago.dir}/classpath.gen"/>

  <!-- Create an MDR repository for use by SQL/MED tests -->
  <target name="createMdrTestData" depends="mdr_taskdef">
    <delete quiet="true">
      <fileset dir="unitsql/ddl" includes="mdr.bt?"/>
    </delete>
    <mdr storageFile="unitsql/ddl/mdr">
      <instantiate name="TestMof"/>
    </mdr>
  </target>

  <target name="testLeaks" depends="all,cleanTestLogs" >
    <javaExec classpathref="farrago.run.classpath"
      classname="net.sf.farrago.test.TestLeaks">
    </javaExec>
  </target>

  <target name="testLeaksJmp" depends="all,cleanTestLogs" >
    <javaExec classpathref="farrago.run.classpath"
      classname="net.sf.farrago.test.TestLeaks">
      <jvmarg line="-Xrunjmp:nomonitors"/>
      <arg value="jmp"/>
    </javaExec>
  </target>

  <!-- run JSwat on Farrago as an RmiJdbc server -->
  <target name="jswat.server" depends="all">
    <jswatDebug
      classpath="${farrago.run.classpath}"
      sourcepath="${server.sourcepath}"
      classname="net.sf.farrago.server.FarragoServer">
    </jswatDebug>
  </target>

  <!-- Below is all experimental stuff for the user repository -->

  <property name="JdbcStorage.prefix"
    value="MDRStorageProperty.org.netbeans.mdr.persistence.jdbcimpl"/>

  <target name="createUserRepository">
    <antFork target="forked_createUserRepository" 
      classpathref="createUserRepository.classpath">
      <jvmargs>
        <jvmarg line="${assertions.jvmarg}"/>
        <jvmarg line="&FarragoProps;"/>
        <sysproperty 
          key="org.netbeans.mdr.storagemodel.StorageFactoryClassName" 
          value="org.netbeans.mdr.persistence.jdbcimpl.JdbcStorageFactory"/>
        <sysproperty 
          key="${JdbcStorage.prefix}.url" 
          value="jdbc:farrago:"/>
        <sysproperty 
          key="${JdbcStorage.prefix}.schemaName" 
          value="MDR"/>
        <sysproperty 
          key="${JdbcStorage.prefix}.userName" 
          value="MDR"/>
        <sysproperty 
          key="${JdbcStorage.prefix}.driverClassName" 
          value="net.sf.farrago.jdbc.FarragoJdbcDriver"/>
        <sysproperty 
          key="${JdbcStorage.prefix}.datatype.streamable" 
          value="VARBINARY(10000)"/>
      </jvmargs>
    </antFork>
  </target>

  <target name="jswat.createUserRepository" depends="all">
    <jswatDebug
      classpath="${createUserRepository.classpath}"
      sourcepath="${mdr.sourcepath}"
      classname="org.apache.tools.ant.Main">
      <jvmargs>
        <arg value="-Dorg.netbeans.mdr.storagemodel.StorageFactoryClassName=org.netbeans.mdr.persistence.jdbcimpl.JdbcStorageFactory"/>
        <arg value="-D${JdbcStorage.prefix}.url=jdbc:farrago:"/>
        <arg value="-D${JdbcStorage.prefix}.userName=MDR"/>
        <arg value="-D${JdbcStorage.prefix}.schemaName=MDR"/>
        <arg value="-D${JdbcStorage.prefix}.driverClassName=net.sf.farrago.jdbc.FarragoJdbcDriver"/>
        <arg value="-D${JdbcStorage.prefix}.datatype.streamable=VARBINARY(10000)"/>
      </jvmargs>
      <programargs>
        <arg value="forked_createUserRepository"/>
      </programargs>
    </jswatDebug>
  </target>

  <target name="forked_createUserRepository" depends="mdr_taskdef">
    <mdr>
      <instantiate name="FarragoMetamodel"/>
      <printExtentNames/>
      <readXMI 
        file="${FarragoMetamodel.xmi}"
        extent="FarragoMetamodel"/>
      <printExtentNames/>
      <instantiate 
        name="FarragoCatalog"
        extent="FarragoMetamodel"
        package="Farrago"/>
      <printExtentNames/>
      <readXMI
        file="${FarragoConf.xmi}"
        extent="FarragoCatalog"/>
    </mdr>
  </target>

</project>
